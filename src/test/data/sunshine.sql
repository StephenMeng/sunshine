/*
Navicat MySQL Data Transfer

Source Server         : local
Source Server Version : 50720
Source Host           : localhost:3306
Source Database       : sunshine

Target Server Type    : MYSQL
Target Server Version : 50720
File Encoding         : 65001

Date: 2018-05-29 11:48:59
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for sunshine_article
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_article`;
CREATE TABLE `sunshine_article` (
  `article_id` int(30) NOT NULL AUTO_INCREMENT COMMENT 'id',
  `article_link_id` varchar(64) NOT NULL,
  `channel_id` int(10) NOT NULL,
  `column_id` int(10) NOT NULL,
  `article_title` varchar(255) NOT NULL COMMENT '博客题名',
  `article_abstract` text NOT NULL COMMENT '博客摘要',
  `article_tag` text NOT NULL COMMENT '标签',
  `article_author` varchar(255) NOT NULL COMMENT '作者id',
  `article_comment_count` int(11) NOT NULL COMMENT '评论数',
  `article_view_count` int(11) NOT NULL COMMENT '浏览数',
  `article_content` mediumtext NOT NULL COMMENT '内容',
  `article_link` varchar(255) NOT NULL COMMENT '链接',
  `article_had_been_published` char(1) NOT NULL COMMENT '是否已被发布',
  `article_is_published` char(1) NOT NULL COMMENT '是否发布',
  `article_put_top` char(1) NOT NULL COMMENT '是否置顶',
  `article_create_date` datetime NOT NULL COMMENT '创建时间',
  `article_update_date` datetime NOT NULL COMMENT '更新时间',
  `article_view_pwd` varchar(100) DEFAULT NULL COMMENT '查看密码',
  `private` bit(1) NOT NULL COMMENT '是不是私有的，私有的是指对内展示的博客',
  `deleted` bit(1) NOT NULL,
  PRIMARY KEY (`article_id`),
  KEY `index_link_id` (`article_link_id`) USING HASH
) ENGINE=InnoDB AUTO_INCREMENT=31 DEFAULT CHARSET=utf8mb4 COMMENT='utf8mb4编码';

-- ----------------------------
-- Records of sunshine_article
-- ----------------------------
INSERT INTO `sunshine_article` VALUES ('1', '2a025966bcc84d929c39589b43b37c12', '3', '3', '第一篇文档', 'abstract', 'stephen', '1', '0', '0', 'SpringBoot学习笔记（五）：配置redis 路业', ' ', '0', '0', '0', '2018-05-19 09:48:20', '2018-05-19 09:48:20', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('2', '2a025966bcc84d929c39589b43b37c18', '3', '3', 'solr 入门', 'ab', 'stephen', '1', '0', '0', 'Apache Solr入门教程(初学者之旅) \r\n写在前面：本文涉及solr入门的各方面，请逐行阅读，相信能帮助你对solr有个清晰全面的了解并能简单实用。\r\n\r\n在Apache Solr初学者教程的这个例子中，我们将讨论有关如何安装最新版本的Apache Solr，并告诉你如何配置它。此外，我们将告诉你如何进行使用solr的样本数据文件索引。Apache Solr支持不同格式，包括各种数据库，PDF文件，XML文件，CSV文件等等。在这个例子中，我们将研究如何从一个CSV文件索引数据。\r\n\r\n首选这个例子的环境是Windows。开始Solr安装之前，确保你已经安装了JDK和正确配置JAVA_HOME。\r\n\r\n1.为什么选择Apache Solr\r\nApache Solr是一个功能强大的搜索服务器，它支持REST风格API。Solr是基于Lucene的，Lucene 支持强大的匹配能力，如短语，通配符，连接，分组和更多不同的数据类型。它使用 Apache Zookeeper特别针对高流量进行优化。Apache Solr提供各式各样的功能，我们列出了部分最主要的功能。\r\n\r\n先进的全文搜索功能。\r\nXML，JSON和HTTP - 基于开放接口标准。\r\n高度可扩展和容错。\r\n同时支持模式和无模式配置。\r\n分页搜索和过滤。\r\n支持像英语，德语，中国，日本，法国和许多主要语言\r\n丰富的文档分析。\r\n2.安装Apache Solr\r\n要首先让从以下位置下载最新版本的Apache Solr：\r\n\r\nhttp://lucene.apache.org/solr/downloads.html\r\n\r\n在撰写本文时，可用的稳定版本是5.0.0。Apache Solr经历了从4.XX到5.0.0各种变化了，所以如果你有不同版本的Solr，你需要下载5.xx版本并以此为模板。', '就', '0', '0', '0', '2018-05-19 19:59:44', '2018-05-19 19:59:48', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('8', 'ba5e799c38bd4db5', '3', '2', 'java常见面试题整理   - CSDN博客', 'abstract', '变量;副本;ThreadLocal;用于', '1', '0', '0', 'ThreadLocal Synchronized实现内存共享，ThreadLocal为每个线程维护一个本地变量。 采用空间换时间，它用于线程间的数据隔离，为每一个使用该变量的线程提供一个副本，每个线程都可以独立地改变自己的副本，而不会和其他线程的副本冲突。 ThreadLocal类中维护一个Map，用于存储每一个线程的变量副本，Map中元素的键为线程对', 'https://blog.csdn.net/u012998254/article/details/79246335', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('9', 'e9af96c2cc7e4294', '3', '3', 'Java集合   - CSDN博客', 'abstract', '集合;类型;数据;存储', '1', '0', '0', 'Java集合 数组作为容器，可以存储基本数据类型，也可以存储引用数据类型，数组一旦定义出来，长度就固定了，而且也只能存储引用数据类型，用起来不太方便，需哦一就引出了集合的概念。 集合 集合的长度是可变的，集合中可以存储不同的数据类型，但是集合不能存储基本数据类型 集合中的方法    Collection:     包括      list', 'https://blog.csdn.net/xiongzhouxiong/article/details/79199764', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('10', '70b04259950342f2', '3', '3', 'Java架构师学习路线   - CSDN博客', 'abstract', '技术;java;框架;性能', '1', '0', '0', 'Java架构师，首先要是一个高级java攻城狮，熟练使用各种框架，并知道它们实现的原理。jvm虚拟机原理、调优，懂得jvm能让你写出性能更好的代码;池技术，什么对象池，连接池，线程池……  　　  Java反射技术，写框架必备的技术，但是有严重的性能问题，替代方案java字节码技术;nio，没什么好说的，值得注意的是”直接内存”的特点，使用场景;ja', 'https://blog.csdn.net/yalin7076/article/details/79246662', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('11', '209dbc595ee74690', '3', '3', 'Java消息中间件   - CSDN博客', 'abstract', '消息;中间;可靠;软件', '1', '0', '0', '消息中间件带来的好处：解耦、异步、横向扩展、安全可靠、顺序保证等。1.消息中间件的概述什么是中间件？非底层操作系统软件，非业务应用软件，不是直接给用户使用的，不能直接给客户带来价值的软件统称为中间件。什么是消息中间件？关注于数据的发送和接收，利用高效可靠的异步传输机制集成分布式系统。什么是JMS?Java消息服务(Java Message Service)', 'https://blog.csdn.net/c136547731/article/details/79220299', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('12', 'bacb9ad184924f0b', '3', '3', 'Java知识点集锦   - CSDN博客', 'abstract', '继承;过程;抽象;行为', '1', '0', '0', '1. 面向对象的特征有哪些方面？抽象：抽象是将一类对象的共同特征总结出来构造类的过程，包括数据抽象和行为抽象两方面。抽象只关注对象有哪些属性和行为，并不关注这些行为的细节是什么。继承：继承是从已有类得到继承信息创建新类的过程。提供继承信息的类被称为父类（超类、基类）；得到继承信息的类被称为子类（派生类）。继承让变化中的软件系统有了一定的延续性，同时继承也是封', 'https://blog.csdn.net/FYGu18/article/details/79256718', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('13', '6c14159e518f4c2c', '3', '3', 'java集合框架综述   - CSDN博客', 'abstract', '集合;接口;框架;Java', '1', '0', '0', '一、集合框架图 简化图： 说明：对于以上的框架图有如下几点说明 1.所有集合类都位于java.util包下。Java的集合类主要由两个接口派生而出：Collection和Map，Collection和Map是Java集合框架的根接口，这两个接口又包含了一些子接口或实现类。 2. 集合接口：6个接口（短虚线表示），表示不同', 'https://blog.csdn.net/qq_18395603/article/details/79253315', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('14', 'd0741a1a61264afe', '3', '3', '01-java基础   - CSDN博客', 'abstract', '开发;Java;公司;编程语言', '1', '0', '0', 'Java基础语法 1、Java开发环境搭建 2、HelloWorld案例 3、注释、关键字、标识符 4、数据（数据类型、常量） 01.java语言概述 A: java语言概述 a: Java是sun公司开发的一门编程语言,目前被Oracle公司收购，编程语言就是用来编写软件的。 b: Java的应用 * 开发', 'https://blog.csdn.net/weixin_38847462/article/details/79236852', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('15', 'c4be42b8000b45c7', '3', '3', 'java写卷积神经网络---CupCnn简介   - CSDN博客', 'abstract', '网络;神经;深度;成功', '1', '0', '0', '前言 在机器学习中，卷积神经网络是一种深度前馈人工神经网络，已成功地应用于图像识别。目前，很多的车牌识号识别，人脸识别等都采用卷积神经网络，可以说卷积神经网络在图像识别方面取得了巨大的成功。当前开源的深度学习框架有很多了，比如caffe,tensorflow,torch等，这些深度学习框架包含了完善的卷积神经网络的实现，那么，为什么我们还要自己写卷积神经网', 'https://blog.csdn.net/u011913612/article/details/79253450', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('16', 'e64568df08d64fe4', '3', '3', 'java实名内部类详解   - CSDN博客', 'abstract', '修饰;static;成员;具有', '1', '0', '0', '实名内部类是个很神奇的东西，当有static修饰class时，可以具有静态成员域和静态成员方法，当没有static修饰时，不能具有静态成员方法和静态成员域，但却可以具有static final修饰的成员域（常量池中有字面量的成员域）。为什么？为什么非static修饰的实名内部类可以应用外部类的成员域和成员方法呢？为什么不可以具有静态成员函数？为什么不可以具有', 'https://blog.csdn.net/dhaiuda/article/details/79106514', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('17', '8749272b86c34298', '3', '3', 'java 1.8 新特性   - CSDN博客', 'abstract', '方法;接口;代码;htm', '1', '0', '0', 'http://www.jb51.net/article/48304.htm 一、接口的默认方法 Java 8允许我们给接口添加一个非抽象的方法实现，只需要使用 default关键字即可，这个特征又叫做扩展方法，示例如下： 复制代码代码如下: interface Formula {     double calcu', 'https://blog.csdn.net/nobalwowotou/article/details/79235235', '0', '0', '0', '2018-05-20 05:03:25', '2018-05-20 05:03:25', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('18', 'ee0289fc03214c75', '3', '3', 'Java技能点汇总   - CSDN博客', 'abstract', '汇总;http;blog;csdn', '1', '0', '0', '汇总：1. Java基本功 http://blog.csdn.net/amen_wu/article/details/79522912 汇总：2. SSH、SSM五大框架 http://blog.csdn.net/amen_wu/article/details/79522933 汇总：3. Java附属技能 http://blog.csdn.net', 'https://blog.csdn.net/Amen_Wu/article/details/73800299', '0', '0', '0', '2018-05-20 05:09:53', '2018-05-20 05:09:53', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('19', '3fb5435807be4aaa', '3', '3', 'java 60 行代码写一个简单可用的并且带过期时间的内存缓存   - CSDN博客', 'abstract', '简单;使用;缓存;需要', '1', '0', '0', '60 行代码写一个简单可用的并且带过期时间的内存缓存 在一个小项目中需要特别简单的使用一个缓存。如果要引入 ehcache 等其他第三方缓存还需要增加 各种 jar 甚至需要增加配置文件。特别麻烦。 所以就自己写了一个。 思路也很简单。 1、使用一个  static 修饰的 ConcurrentHashMap 对象保存数据。 2、存入数据的时候', 'https://blog.csdn.net/wab719591157/article/details/78029861', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('20', '7b4ae33ca68f4d5b', '3', '3', 'java爬虫爬取网站使用多线程(虎嗅网站)   - CSDN博客', 'abstract', 'org;pom;jsoup;方案', '1', '0', '0', '图解虎嗅爬虫优化方案 pom 如下: org.apache.httpcomponents httpclient 4.5.3 org.jsoup jsoup 1.10.3 org.springframework spring-jdbc 4.2.6.RELEASE', 'https://blog.csdn.net/HUIJINJAVA/article/details/79232189', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('21', 'fcfb0d57ecd94a0b', '3', '3', 'Java.util   - CSDN博客', 'abstract', '提供;Java;日期;产生', '1', '0', '0', '介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。本章介绍Java的实用工具类库java.util包。在这个包中，Java提供了一些实用的方法和数据结构。例如，Java提供日期(Data)类、日历(Calendar)类来产生和获取日期及时间，提供随机数(Random)类产生各种类型的随机数，还提供了堆栈(', 'https://blog.csdn.net/qq_41312575/article/details/79249006', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('22', '19cfaccfb28a46ea', '3', '3', '常见类和包的一些整理——java.time.*   - CSDN博客', 'abstract', '时间;日期;类型;操作', '1', '0', '0', 'Date & Time 日期/时间类型是常见数据类型。处理日期/时间是频繁的操作。 常见对日期/时间类型的数据需要的操作： 获取日期/时间，计算两个日期/时间之间的跨度，加上/减去一些时间，日期/时间类型与不同格式字符串的转换。 现存类： java.util.* java.util.Date since JDK 1.0 能够支', 'https://blog.csdn.net/yuki91612/article/details/79238809', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '\0', '\0');
INSERT INTO `sunshine_article` VALUES ('23', '8110b0eee51f471c', '3', '3', '私有：java使用AWS S3 SDK 上传文件至 DigitalOcean Spaces   - CSDN博客', 'abstract', 'java;import;io;util', '1', '0', '0', 'import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.InputStream; import java.util.Date; import java.util.Properties; import', 'https://blog.csdn.net/www359956085/article/details/79235823', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '', '\0');
INSERT INTO `sunshine_article` VALUES ('24', 'fb6889d5bfb64965', '3', '3', '私有：java NIO学习之基础   - CSDN博客', 'abstract', '阻塞;IO;版本;提供', '1', '0', '0', '一.简介Java NIO是从Java 1.4版本开始针对原Java IO所开发的一套新的IO api接口。为所有的原始类型（boolean类型除外）提供缓存支持的数据容器，并使用同步非阻塞模型可以提供非阻塞式的高伸缩性网络。拓展：Tomcat版本1）6.0 -- BIO 同步阻塞式IO 2）7.0 -- NIO 同步非阻塞式IO3）8.0 -- AIO', 'https://blog.csdn.net/wang_snake/article/details/79239544', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '', '\0');
INSERT INTO `sunshine_article` VALUES ('25', '9d60d0910c564b71', '3', '3', '私有：Java多线程之Callable和Future   - CSDN博客', 'abstract', 'Callable;返回;拿到;Future', '1', '0', '0', '本篇说明的是Callable和Future，它俩很有意思的，一个产生结果，一个拿到结果。 Callable接口类似于Runnable，从名字就可以看出来了，但是Runnable不会返回结果，并且无法抛出返回结果的异常，而Callable功能更强大一些，被线程执行后，可以返回值，这个返回值可以被Future拿到，也就是说，Future可以拿到异步执行任务的返回', 'https://blog.csdn.net/FYGu18/article/details/79226631', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '', '\0');
INSERT INTO `sunshine_article` VALUES ('26', '1ec5e46fcc9847ba', '3', '3', '私有：java之接口interface   - CSDN博客', 'abstract', '方法;接口;抽象;定义', '1', '0', '0', '除非实现接口的类是抽象类，否则该类要定义接口中的所有方法。接口就向又定义了一个功能的类 接口无法被实例化，但是可以被实现。一个实现接口的类，必须实现接口内所描述的所有方法，否则就必须声明为抽象类。 接口特性 接口中每一个方法也是隐式抽象的,接口中的方法会被隐式的指定为 public abstract（只能是 public a', 'https://blog.csdn.net/qq_32863631/article/details/79228177', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '', '\0');
INSERT INTO `sunshine_article` VALUES ('27', '674992dc4b074443', '3', '3', '私有：java.lang.NoClassDefFoundError: org/springframework/core/io/Resource   - CSDN博客', 'abstract', 'org;springframework;listener;class', '1', '0', '0', '严重: Error configuring application listener of class org.springframework.web.context.ContextLoaderListener java.lang.NoClassDefFoundError: org/springframework/core/io/Resource at', 'https://blog.csdn.net/qq_30938705/article/details/79257044', '0', '0', '0', '2018-05-20 05:09:55', '2018-05-20 05:09:55', 'pwd', '', '\0');
INSERT INTO `sunshine_article` VALUES ('30', '3db28077614c4cbb', '3', '1', '新测试题名', '[第四次的正文]', 'stephen，ice，新标签', '1', '0', '0', '第四次的正文？', '11121', '0', '1', '0', '2018-05-22 06:51:29', '2018-05-22 07:35:55', null, '\0', '\0');

-- ----------------------------
-- Table structure for sunshine_attachment
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_attachment`;
CREATE TABLE `sunshine_attachment` (
  `att_id` int(20) NOT NULL AUTO_INCREMENT,
  `att_type` varchar(255) NOT NULL COMMENT '文件类型',
  `uploader` int(30) NOT NULL COMMENT '上传者',
  `owner_id` int(30) NOT NULL COMMENT '所有者',
  `owner_type` int(10) NOT NULL COMMENT '所有者类型：1:文章，2：用户',
  `att_name` varchar(255) NOT NULL COMMENT '文件名',
  `att_uri` varchar(255) NOT NULL COMMENT '文件位置',
  `att_length` double NOT NULL COMMENT '文件长度',
  `upload_date` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  `update_date` datetime NOT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`att_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_attachment
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_book
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_book`;
CREATE TABLE `sunshine_book` (
  `alt` varchar(255) NOT NULL,
  `title` varchar(512) NOT NULL,
  `author` varchar(255) DEFAULT NULL,
  `binding` varchar(255) DEFAULT NULL,
  `catalog` longtext,
  `id` varchar(255) DEFAULT NULL,
  `image` varchar(255) DEFAULT NULL,
  `isbn10` varchar(255) DEFAULT NULL,
  `isbn13` varchar(255) DEFAULT NULL,
  `pages` varchar(255) DEFAULT NULL,
  `price` varchar(255) DEFAULT NULL,
  `pubdate` varchar(255) DEFAULT NULL,
  `publisher` varchar(255) DEFAULT NULL,
  `subtitle` varchar(255) DEFAULT NULL,
  `summary` longtext,
  `tags` varchar(255) DEFAULT NULL,
  `translator` varchar(255) DEFAULT NULL,
  `url` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`alt`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_book
-- ----------------------------
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/10484692/', 'Java并发编程实战', '[\"Brian Goetz\",\"Tim Peierls\",\"Joshua Bloch\",\"Joseph Bowbeer\",\"David Holmes\",\"Doug Lea\"]', '平装', '对本书的赞誉\n译者序\n前　言\n第1章　简介1\n1.1　并发简史1\n1.2　线程的优势2\n1.2.1　发挥多处理器的强大能力2\n1.2.2　建模的简单性3\n1.2.3　异步事件的简化处理3\n1.2.4　响应更灵敏的用户界面4\n1.3　线程带来的风险4\n1.3.1　安全性问题5\n1.3.2　活跃性问题7\n1.3.3　性能问题7\n1.4　线程无处不在7\n第一部分　基础知识\n第2章　线程安全性11\n2.1　什么是线程安全性13\n2.2　原子性14\n2.2.1　竞态条件15\n2.2.2　示例：延迟初始化中的竞态条件16\n2.2.3　复合操作17\n2.3　加锁机制18\n2.3.1　内置锁20\n2.3.2　重入21\n2.4　用锁来保护状态22\n2.5　活跃性与性能23\n第3章　对象的共享27\n3.1　可见性27\n3.1.1　失效数据28\n3.1.2　非原子的64位操作29\n3.1.3　加锁与可见性30\n3.1.4　Volatile变量 30\n3.2　发布与逸出32\n3.3　线程封闭35\n3.3.1　Ad-hoc线程封闭35\n3.3.2　栈封闭36\n3.3.3　ThreadLocal类37\n3.4　不变性38\n3.4.1　Final域39\n3.4.2　示例：使用Volatile类型来发布不可变对象40\n3.5　安全发布41\n3.5.1　不正确的发布：正确的对象被破坏42\n3.5.2 　不可变对象与初始化安全性42\n3.5.3　安全发布的常用模式43\n3.5.4　事实不可变对象44\n3.5.5　可变对象44\n3.5.6　安全地共享对象44\n第4章　对象的组合46\n4.1　设计线程安全的类46\n4.1.1　收集同步需求47\n4.1.2　依赖状态的操作48\n4.1.3　状态的所有权48\n4.2　实例封闭49\n4.2.1　Java监视器模式51\n4.2.2　示例：车辆追踪51\n4.3　线程安全性的委托53\n4.3.1　示例：基于委托的车辆追踪器54\n4.3.2　独立的状态变量55\n4.3.3　当委托失效时56\n4.3.4　发布底层的状态变量57\n4.3.5　示例：发布状态的车辆追踪器58\n4.4　在现有的线程安全类中添加功能59\n4.4.1　客户端加锁机制60\n4.4.2　组合62\n4.5　将同步策略文档化62\n第5章　基础构建模块66\n5.1　同步容器类66\n5.1.1　同步容器类的问题66\n5.1.2　迭代器与Concurrent-ModificationException68\n5.1.3　隐藏迭代器69\n5.2　并发容器70\n5.2.1　ConcurrentHashMap71\n5.2.2　额外的原子Map操作72\n5.2.3　CopyOnWriteArrayList72\n5.3　阻塞队列和生产者-消费者模式73\n5.3.1　示例：桌面搜索75\n5.3.2　串行线程封闭76\n5.3.3　双端队列与工作密取77\n5.4　阻塞方法与中断方法77\n5.5　同步工具类78\n5.5.1　闭锁79\n5.5.2　FutureTask80\n5.5.3　信号量82\n5.5.4　栅栏83\n5.6　构建高效且可伸缩的结果缓存85\n第二部分　结构化并发应用程序\n第6章　任务执行93\n6.1　在线程中执行任务93\n6.1.1　串行地执行任务94\n6.1.2　显式地为任务创建线程94\n6.1.3　无限制创建线程的不足95\n6.2　Executor框架96\n6.2.1　示例：基于Executor的Web服务器97\n6.2.2　执行策略98\n6.2.3　线程池98\n6.2.4　Executor的生命周期99\n6.2.5　延迟任务与周期任务101\n6.3　找出可利用的并行性102\n6.3.1　示例：串行的页面渲染器102\n6.3.2　携带结果的任务Callable与Future103\n6.3.3　示例：使用Future实现页面渲染器104\n6.3.4　在异构任务并行化中存在的局限106\n6.3.5　CompletionService:Executor与BlockingQueue106\n6.3.6　示例：使用CompletionService实现页面渲染器107\n6.3.7　为任务设置时限108\n6.3.8　示例：旅行预定门户网站109\n第7章　取消与关闭111\n7.1　任务取消111\n7.1.1　中断113\n7.1.2　中断策略116\n7.1.3　响应中断117\n7.1.4　示例：计时运行118\n7.1.5　通过Future来实现取消120\n7.1.6　处理不可中断的阻塞121\n7.1.7　采用newTaskFor来封装非标准的取消122\n7.2　停止基于线程的服务124\n7.2.1　示例：日志服务124\n7.2.2　关闭ExecutorService127\n7.2.3　“毒丸”对象128\n7.2.4　示例：只执行一次的服务129\n7.2.5　shutdownNow的局限性130\n7.3　处理非正常的线程终止132\n7.4　JVM关闭135\n7.4.1　关闭钩子135\n7.4.2　守护线程136\n7.4.3　终结器136\n第8章　线程池的使用138\n8.1　在任务与执行策略之间的隐性耦合138\n8.1.1　线程饥饿死锁139\n8.1.2　运行时间较长的任务140\n8.2　设置线程池的大小140\n8.3　配置ThreadPoolExecutor141\n8.3.1　线程的创建与销毁142\n8.3.2　管理队列任务142\n8.3.3　饱和策略144\n8.3.4　线程工厂146\n8.3.5　在调用构造函数后再定制ThreadPoolExecutor147\n8.4　扩展 ThreadPoolExecutor148\n8.5　递归算法的并行化149\n第9章　图形用户界面应用程序156\n9.1　为什么GUI是单线程的156\n9.1.1　串行事件处理157\n9.1.2　Swing中的线程封闭机制158\n9.2　短时间的GUI任务160\n9.3　长时间的GUI任务161\n9.3.1　取消162\n9.3.2　进度标识和完成标识163\n9.3.3　SwingWorker165\n9.4　共享数据模型165\n9.4.1　线程安全的数据模型166\n9.4.2　分解数据模型166\n9.5　其他形式的单线程子系统167\n第三部分　活跃性、性能与测试\n第10章　避免活跃性危险169\n10.1　死锁169\n10.1.1　锁顺序死锁170\n10.1.2　动态的锁顺序死锁171\n10.1.3　在协作对象之间发生的死锁174\n10.1.4　开放调用175\n10.1.5　资源死锁177\n10.2　死锁的避免与诊断178\n10.2.1　支持定时的锁178\n10.2.2　通过线程转储信息来分析死锁178\n10.3　其他活跃性危险180\n10.3.1　饥饿180\n10.3.2　糟糕的响应性181\n10.3.3　活锁181\n第11章　性能与可伸缩性183\n11.1　对性能的思考183\n11.1.1　性能与可伸缩性184\n11.1.2　评估各种性能权衡因素185\n11.2　Amdahl定律186\n11.2.1　示例：在各种框架中隐藏的串行部分188\n11.2.2　Amdahl定律的应用189\n11.3　线程引入的开销189\n11.3.1　上下文切换190\n11.3.2　内存同步190\n11.3.3　阻塞192\n11.4　减少锁的竞争192\n11.4.1　缩小锁的范围（“快进快出”）193\n11.4.2　减小锁的粒度195\n11.4.3　锁分段196\n11.4.4　避免热点域197\n11.4.5　一些替代独占锁的方法198\n11.4.6　监测CPU的利用率199\n11.4.7　向对象池说“不”200\n11.5　示例：比较Map的性能200\n11.6　减少上下文切换的开销201\n第12章　并发程序的测试204\n12.1　正确性测试205\n12.1.1　基本的单元测试206\n12.1.2　对阻塞操作的测试207\n12.1.3　安全性测试208\n12.1.4　资源管理的测试212\n12.1.5　使用回调213\n12.1.6　产生更多的交替操作214\n12.2　性能测试215\n12.2.1　在PutTakeTest中增加计时功能215\n12.2.2　多种算法的比较217\n12.2.3　响应性衡量218\n12.3　避免性能测试的陷阱220\n12.3.1　垃圾回收220\n12.3.2　动态编译220\n12.3.3　对代码路径的不真实采样222\n12.3.4　不真实的竞争程度222\n12.3.5　无用代码的消除223\n12.4　其他的测试方法224\n12.4.1　代码审查224\n12.4.2　静态分析工具224\n12.4.3　面向方面的测试技术226\n12.4.4　分析与监测工具226\n第四部分　高级主题\n第13章　显式锁227\n13.1　Lock与 ReentrantLock227\n13.1.1　轮询锁与定时锁228\n13.1.2　可中断的锁获取操作230\n13.1.3　非块结构的加锁231\n13.2　性能考虑因素231\n13.3　公平性232\n13.4　在synchronized和ReentrantLock之间进行选择234\n13.5　读-写锁235\n第14章　构建自定义的同步工具238\n14.1　状态依赖性的管理238\n14.1.1　示例：将前提条件的失败传递给调用者240\n14.1.2　示例：通过轮询与休眠来实现简单的阻塞241\n14.1.3　条件队列243\n14.2　使用条件队列244\n14.2.1　条件谓词244\n14.2.2　过早唤醒245\n14.2.3　丢失的信号246\n14.2.4　通知247\n14.2.5　示例：阀门类248\n14.2.6　子类的安全问题249\n14.2.7　封装条件队列250\n14.2.8　入口协议与出口协议250\n14.3　显式的Condition对象251\n14.4　Synchronizer剖析253\n14.5　AbstractQueuedSynchronizer254\n14.6　java.util.concurrent同步器类中的 AQS257\n14.6.1　ReentrantLock257\n14.6.2　Semaphore与CountDownLatch258\n14.6.3　FutureTask259\n14.6.4　ReentrantReadWriteLock259\n第15章　原子变量与非阻塞同步机制261\n15.1　锁的劣势261\n15.2　硬件对并发的支持262\n15.2.1　比较并交换263\n15.2.2　非阻塞的计数器264\n15.2.3　JVM对CAS的支持265\n15.3　原子变量类265\n15.3.1　原子变量是一种“更好的volatile”266\n15.3.2　性能比较：锁与原子变量267\n15.4　非阻塞算法270\n15.4.1　非阻塞的栈270\n15.4.2　非阻塞的链表272\n15.4.3　原子的域更新器274\n15.4.4　ABA问题275\n第16章　Java内存模型277\n16.1　什么是内存模型，为什么需要它277\n16.1.1　平台的内存模型278\n16.1.2　重排序278\n16.1.3　Java内存模型简介280\n16.1.4　借助同步281\n16.2　发布283\n16.2.1　不安全的发布283\n16.2.2　安全的发布284\n16.2.3　安全初始化模式284\n16.2.4　双重检查加锁286\n16.3　初始化过程中的安全性287\n附录A　并发性标注289\n参考文献291', '10484692', 'https://img3.doubanio.com/view/subject/m/public/s7663093.jpg', '711137004X', '9787111370048', '293', '69.00元', '2012-2', '机械工业出版社华章公司', '', '本书深入浅出地介绍了Java线程和并发，是一本完美的Java并发参考手册。书中从并发性和线程安全性的基本概念出发，介绍了如何使用类库提供的基本并发构建块，用于避免并发危险、构造线程安全的类及验证线程安全的规则，如何将小的线程安全类组合成更大的线程安全类，如何利用线程来提高并发应用程序的吞吐量，如何识别可并行执行的任务，如何提高单线程子系统的响应性，如何确保并发程序执行预期任务，如何提高并发代码的性能和可伸缩性等内容，最后介绍了一些高级主题，如显式锁、原子变量、非阻塞算法以及如何开发自定义的同步工具类。\n本书适合Java程序开发人员阅读。', 'Java;并发;多线程;编程;计算机;java;软件开发;线程;', '[\"童云兰\"]', 'https://api.douban.com/v2/book/10484692');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1138768/', '深入Java虚拟机(原书第2版)', '[\"（美）文纳斯\"]', '平装', '译者序\n前言\n第1章 Java体系结构介绍\n第2章 平台无关\n第3章 安全\n第4章 网络移动性\n第5章 Java虚拟机\n第6章 Java class文件\n第7章 类型的生命周期\n第8章 连接模型\n第9章 垃圾收集\n第10章 栈和局部变量操作\n第11章 类型转换\n第12章 整数运算\n第13章 逻辑运算\n第14章 浮点运算\n第15章 对象和数组\n第16章 控制流\n第17章 异常\n第18章 finally子句\n第19章 方法的调用与返回\n第20章 指令invokespecial\n第21章 线程同步\n附录A 按操作码助记符排列的指令集\n附录B 按功能排列的操作码助记符\n附录C 按操作码字节值排列的操作码助记符\n附录D Java虚拟机的一个模拟：“Slices of Pi”', '1138768', 'https://img1.doubanio.com/view/subject/m/public/s1106498.jpg', '7111128052', '9787111128052', '461', '58.00元', '2003-9', '机械工业出版社', '', '本书作者曾因本书荣获专业技术杂志《Java Report》评选的优秀作者奖，细心的读者可以从网上找到许多对本书第1版的赞誉。作者以易于理解的方式深入揭示了Java虚拟机的内部工作原理，深入理解这些内容，将对读者更快速地编写更高效的程序大有裨益！\n本书共分20章，第1-4章解释了Java虚拟机的体系结构，包括Java栈、堆、方法区、执行引擎等；第5-20章深入描述了Java技术的内部细节，包括垃圾收集、Java安全模型、Java的连接模型和动态扩展机制、class文件、运算及流程控制等等，其中第6章和附录A-C安全可以作为class文件和指令集的参考手册。本书还附带光盘，光盘中包含用以辅助说明正文内容的交互式例示applet及示例源代码。', 'java;jvm;虚拟机;深入Java虚拟机;Java;计算机;软件开发;编程;', '[\"曹晓钢\",\"蒋靖\"]', 'https://api.douban.com/v2/book/1138768');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1168545/', '爪哇夜未眠（第二版）', '[\"蔡学镛\"]', '平装(无盘)', '1 生涯篇\n2 程序设计学习篇\n3 REBOL篇\n4 牢骚篇\n5 励志篇\n6 系统篇\n7 软件工程篇\n8 杂感篇\n9 图书篇', '1168545', 'https://img3.doubanio.com/view/subject/m/public/s1123211.jpg', '7505399578', '9787505399570', '215', '20.00元', '2004-7-1', '电子工业出版社', 'Java程序员心声', '本书是一本散文集。作为一名资深Java程序设计师，作者用清新自然的笔触记录下自己学习、工作生活中的所见所思。书中收录的文章内容贴近程序员的生活，令读者产生强烈共鸣。此外，书中部分文章也以轻松的风格介绍了学习Java技术时的一些常见问题，并介绍了一些优秀的Java书籍，能够帮助读者兴趣盎然地学习Java技术。\n本书适合于Java程序员、专业软件开发者、程序设计爱好者阅读。', 'Java;程序人生;计算机;技术杂文;蔡学镛;杂文;编程;程序设计;', '[]', 'https://api.douban.com/v2/book/1168545');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1229955/', 'Thinking in Java (3rd Edition)', '[\"Bruce Eckel\"]', 'Paperback', '', '1229955', 'https://img1.doubanio.com/view/subject/m/public/s1656369.jpg', '0131002872', '9780131002876', '', 'USD 54.99', '2002-12-06', 'Prentice Hall PTR', 'Thinking in Java,Third Edition 英文电子版', 'Bruce Eckel\'s Thinking in Java - JavaWorld Editor\'s Choice Award for Best  Book, 2001 JavaWorld Reader\'s Choice Award for Best Book, 2000 Software  Development Magazine Productivity Award, 1999 Java Developer\'s Journal  Editor\'s Choice Award for Best Book, 1998 Software Development Magazine  Jolt Product Excellence Award (for Thinking in C++), 1995 Thinking in Java has earned raves from programmers worldwide for its extraordinary clarity, careful organization, and small, direct programming examples. From the  fundamentals of Java syntax to its most advanced features (in-depth  object-oriented concepts, multithreading, automated project building, unit testing, and debugging), Thinking in Java is designed to teach, one simple step at a time. The classic Java Introduction, fully updated for Java 2  version 1.4, with new topics throughout! New testing framework validates  each program and shows you the output. New chapter on unit testing,  automated building, assertions, logging, debugging, and other ways to keep your programs in tune. Completely rewritten threading chapter gives you a  solid grasp of the fundamentals. 350+ working Java programs, rewritten for this edition. 15,000+ lines of code. Companion web site includes all  source code, annotated solution guide, essays and other resources.  Includes entire Foundations for Java multimedia seminar on CD-ROM for  Windows, Linux and Mac. For beginners and experts alike. Teaches Java  linguistics, not platform-dependent mechanics. Thorough coverage of  fundamentals; demonstrates advanced topics. Explains sound object-oriented principles as they apply to Java. Hands-on Java CD available online, with  15 hours of lectures and slides by Bruce Eckel. Live seminars, consulting, and reviews available. www.BruceEckel.com What people are saying- \"The  best book on Java...Your depth is amazing.\" \"Definitely the thinking  person\'s choice in a Java book.\" \"One of the absolutely best programming  tutorials I\'ve seen, for any language.\"  ', 'java;Programming;编程;计算机;Java;编程语言;技术;thinking;', '[]', 'https://api.douban.com/v2/book/1229955');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1246129/', 'Effective Java', '[\"Joshua Bloch\"]', 'Paperback', '', '1246129', 'https://img1.doubanio.com/view/subject/m/public/s1408749.jpg', '0201310058', '9780201310054', '272', '$44.99', '05 June, 2001', 'Addison-Wesley Professional', 'Programming Language Guide (Java Series)', 'Effective Java Programming Language Guide distills the hard-won wisdom of today\'s best Java programmers into 50 techniques for designing and constructing more robust, high-performance software. Josh Bloch, one of Sun\'s most widely respected Java developers, focuses on the practical problems virtually every Java developer encounters, offering specific solutions and top-notch code examples. Josh Bloch identifies 50 practices that lead directly to better code -- including better alternatives for common practices that have proven undesirable in real-world development. The techniques are specific, thoroughly explained, and supported by top-notch code examples. Among the highlights: why developers should avoid finalizers; when to use delegation instead of inheritance; and how to make the most of Java\'s powerful typesafe enum pattern. Nearly all 50 practices relate to the \"core\" of the Java platform -- the language itself -- making the book relevant to virtually every Java developer.', 'Java;programming;软件开发;编程;effective;计算机;程序设计;高效;', '[]', 'https://api.douban.com/v2/book/1246129');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1315050/', '精通Hibernate', '[\"孙卫琴\"]', '平装', '第1章 Java对象持久化技术概述\n1.1 应用程序的分层体系结构\n1.2 软件的模型\n1.3 直接通过JDBC API来持久化实体域对象\n1.4 ORM简介\n1.5 实体域对象的其他持久化模式\n1.6 Hibernate API简介\n1.7 小结\n第2章 Hibernate入门\n2.1 创建Hibernate的配置文件46\n2.2 创建持久化类\n2.3 创建数据库Schema\n2.4 创建对象-关系映射文件\n2.5 通过HibernateAPI操纵数据库\n2.6 运行helloapp应用\n2.7 小结\n第3章 hbm2java和hbm2ddl工具\n3.1 创建对象-关系映射文件\n3.2 建立项目的目录结构\n3.3 运行hbm2java工具\n3.4 运行hbm2ddl工具\n3.5 小结\n第4章 对象-关系映射基础\n4.1 持久化类的属性及访问方法\n4.2 处理SQL引用标识符\n4.3 创建命名策略\n4.4 设置命名Schema\n4.5 设置类的包名\n4.6 运行本章的范例程序\n4.7 小结\n第5章 映射对象标识符\n5.1 关系数据库按主键区分不同的记录\n5.2 Java语言按内存地址区分不同的对象\n5.3 Hibernate用对象标识符（OID）来区分对象\n5.4 Hibernate的内置标识符生成器的用法\n5.5 映射自然主键\n5.6 小结\n第6章 映射一对多关联关系\n……\n第7章 操纵持久化对象\n第8章 映射组成关系\n第9章 Hibernate的映射类型\n第10章 Hibernate的检索策略\n第11章 Hibernate的检索方式\n第12章 数据库事务与并发\n第13章 管理Hibernate的缓存\n第14章 映射继承关系\n第15章 Java集合类\n第16章 映射值类型集合\n第17章 映射实体关联关系\n第18章 Hibernate高级配置\n第19章 Hibernate与Struts框架\n第20章 Hibernate与EJB组件\n附录A 标准SQL语言的用法\n附录B Java语言的反射机制\n附录C 用XDoclet工具生成映射文件\n附录D 发布和运行netstore应用\n参考文献', '1315050', 'https://img3.doubanio.com/view/subject/m/public/s1321842.jpg', '7121011360', '9787121011368', '598', '59.00元', '2005-5', '电子工业出版社', 'Java对象持久化技术详解.', 'Hibernate 是非常流行的对象-关系映射工具。本书详细介绍了运用目前最成熟的 Hibernate 2.1 版本进行 Java 对象持久化的技术。 Hibernate 是连接 Java 对象模型和关系数据模型的桥梁，通过本书，读者不仅能掌握用 Hibernate 工具对这两种模型进行映射的技术，还能获得设计与开发 Java 对象模型和关系数据模型的先进经验。书中内容注重理论与实践相结合，列举了大量具有典型性和实用价值的 Hibernate 应用实例，并提供了详细的开发和部署步骤。随书附赠光盘内容为本书所有范例源程序，以及本书涉及的软件的最新版本的安装程序。\n本书无论对于 Java 开发的新手还是行家来说，都是精通 Java 对象持久化技术的必备实用手册。', 'Hibernate;Java;orm;计算机;精通Hibernate;j2ee;OpenSource;编程;', '[]', 'https://api.douban.com/v2/book/1315050');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1449002/', '项目自动化之道', '[\"（美）克菜珂（Clark M.)\"]', '简裝本', '关于程序员修炼三部曲\n前言\n第1章 序言\n1.1 瞧，不用手就能搞定\n1.2 自动化的类型\n1.3 关于自动化的问题\n1.4 路线图\n第2章 单步建构\n2.1 建构软件很像做香肠\n2.2 选择项目目录结构\n2.3 生成你的首个建构\n2.4 用 Ant 建构\n2.5 对建构进行“口味测试”\n2.6 打扫战场\n2.7 脚本化建构\n2.8 提早开始\n2.9 小结\n第3章 定时建构\n3.1 定时首个建构\n3.2 将建构置于 CruiseControl\n3.3 运行 CruiseControl\n3.4 发表建构状态\n3.5 更上一层楼\n3.6 小结\n第4章 按键发布\n4.1 早日并频繁地产生发布\n4.2 准备第一款发布\n4.3 对发布打包\n4.4 产生发布\n4.5 对发布打标\n4.6 提交发布\n4.7 发布流程的自动化\n4.8 每日产生发布\n4.9 小结\n第5章 安装与部署\n5.1 呈交产品\n5.2 安装标准分发文件\n5.3 通过电话排除故障\n5.4 用诊断测试排除故障\n5.5 增强安装形象\n5.6 部署托管应用\n5.7 自动更新已安装的应用\n5.8 小结\n第6章 监控\n6.1 监控定时建构\n6.2 从可视装置取得反馈信息\n6.3 监控 Java 进程\n6.4 对 Web 应用“体检”\n6.5 监视日志文件\n6.6 用 log4j 监控\n6.7 用 RSS 建构“遥感线”\n6.8 用调试命令监控健康状况\n6.9 生成崩溃报告\n6.10 3-2-1\n6.11 自动化\n附录A 资源\nA.1 网络资源\nA.2 参考书目\n附录B 项目自动化之道：概要\n索引', '1449002', 'https://img3.doubanio.com/view/subject/m/public/s1581820.jpg', '7121017652', '9787121017650', '161', '25.00元', '2005-09-01', '电子工业出版社', '如何建构部署监控Java应用', '', '软件工程;自动化;Java;项目管理;计算机;软件开发;ant;AgileProgramming;', '[\"张菲\"]', 'https://api.douban.com/v2/book/1449002');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1725491/', '面向对象程序设计-Java', '[\"张白一，崔尚森编著\"]', '', '', '1725491', 'https://img3.doubanio.com/view/subject/m/public/s11145611.jpg', '7560616054', '9787560616056', '360', '32.00元', '2006-1', '陕西西安电子科技大学', 'Java', '面向对象程序设计-Java（第二版），ISBN：9787560616056，作者：张白一 等编著', '编程语言;教材;', '[]', 'https://api.douban.com/v2/book/1725491');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1781451/', 'JAVA 2核心技术 卷Ⅰ', '[\"[美] 霍斯特曼\",\"[美] 科奈尔\"]', '平装', '', '1781451', 'https://img3.doubanio.com/view/subject/m/public/s1815135.jpg', '7111185234', '9787111185239', '691', '88.00元', '2006-5', '机械工业出版社', '基础知识', '本书是Java技术经典参考书，多年畅销不衰，第7版在保留以前版本风格的基础上，涵盖Java2开发平台标准版J2SE5.0的基础知识，主要内容包括面各对象程序设计、反射与代理、接口与内部类、事件监听器模型、使用Swing UI工具箱进行图形用户界面设计，异常处理、流输入/输出和对象序列化、泛型程序设计等。\n本书内容翔实、深入浅出，附有大量程序实例，极具实用价值，是Java初学者和Java程序员的必备参考书。', 'JAVA;编程;计算机;java基础;JAVA2核心技术;Java;经典;程序设计;', '[\"叶乃文\",\"邝劲筠 等\"]', 'https://api.douban.com/v2/book/1781451');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1886305/', '数据结构与算法', '[\"德罗兹德克\"]', '平装', '第1章 java语言的面向对象编程 1\n1.1 java入门 1\n1.1.1 变量的声明 1\n1.1.2 运算符 3\n1.1.3 选择语句 3\n1.1.4 循环语句 4\n1.1.5 异常处理 5\n1.2 java面向对象编程 6\n1.2.1 封装 6\n1.2.2 抽象数据类型 12\n1.2.3 继承 13\n1.2.4 多态性 16\n1.3 输入和输出 19\n1.3.1 输入、输出字节 21\n1.3.2 行输入 21\n1.3.3 标志输入：单词和数字 22\n1.3.4 基本数据类型的输入和输出 22\n1.3.5 对象的输入和输出 23\n1.3.6 随机存取文件 24\n1.4 java和指针 24\n1.5 java.util中的向量 28\n1.6 数据结构和面向对象的编程 32\n1.7 示例学习：随机存取文件 32\n1.8 习题 39\n1.9 编程作业 41\n参考文献 42\n第2章 复杂性分析 44\n2.1 计算复杂性和渐近复杂性 44\n2.2 大o表示法 44\n2.3 大o表示法的性质 46\n2.4 w和q表示法 47\n2.5 可能出现的问题 48\n2.6 复杂性示例 48\n2.7 寻找渐近复杂性：示例 49\n2.8 最好的、平均的和最坏的情况 51\n2.9 平摊复杂性 53\n2.10 np完整性 56\n2.11 习题 58\n参考文献 60\n第3章 链表 62\n3.1 单向链表 62\n3.1.1 插入 66\n3.1.2 删除 67\n3.1.3 查找 70\n3.2 双向链表 72\n3.3 循环链表 74\n3.4 跳转表 75\n3.5 自组织表 80\n3.6 稀疏表 83\n3.7 java.util的链表 85\n3.7.1 linkedlist 85\n3.7.2 arraylist 89\n3.8 结论 91\n3.9 示例学习：图书馆 92\n3.10 习题 99\n3.11 编程作业 101\n参考文献 103\n第4章 堆栈和队列 105\n4.1 堆栈 105\n4.2 队列 111\n4.3 优先级队列 117\n4.4 示例学习：脱离迷宫 118\n4.5 习题 122\n4.6 编程作业 124\n参考文献 125\n第5章 递归 126\n5.1 递归定义 126\n5.2 方法调用和递归实现 128\n5.3 剖析递归调用 129\n5.4 尾递归 132\n5.5 非尾递归 133\n5.6 间接递归 137\n5.7 嵌套递归 139\n5.8 过分递归 139\n5.9 回溯 142\n5.10 小结 147\n5.11 示例学习：递归下降解 推?147\n5.12 习题 153\n5.13 编程作业 155\n参考文献 157\n第6章 二叉树 158\n6.1 树、二叉树和二叉查找树 158\n6.2 二叉树实现 161\n6.3 搜索二叉查找树 163\n6.4 树的遍历 164\n6.4.1 广度优先遍历 165\n6.4.2 深度优先遍历 165\n6.4.3 无堆栈深度优先遍历 171\n6.5 插入 175\n6.6 删除 178\n6.6.1 归并删除法 179\n6.6.2 复制删除法 181\n6.7 树的平衡 183\n6.7.1 dsw算法 185\n6.7.2 avl树 187\n6.8 自调整树 191\n6.8.1 自重构树 192\n6.8.2 伸展树 192\n6.9 堆 196\n6.9.1 堆作为优先级队列 197\n6.9.2 以堆的形式组织数组 199\n6.10 波兰表示法和表达式树 202\n6.11 示例学习：计算单词频率 206\n6.12 习题 212\n6.13 编程作业 214\n参考文献 217\n第7章 多分树 220\n7.1 b树家族 220\n7.1.1 b树 221\n7.1.2 b*树 229\n7.1.3 b+树 230\n7.1.4 前缀b+树 232\n7.1.5 比特树 233\n7.1.6 r树 235\n7.1.7 2-4树 236\n7.1.8 java.util中的树 248\n7.2 检索树 257\n7.3 结论 264\n7.4 示例学习：拼写检查程序 264\n7.5 习题 273\n7.6 编程作业 274\n参考文献 277\n第8章 图 279\n8.1 图的表示法 280 ..\n8.2 图的遍历 281\n8.3 最短路径 284\n8.4 圈检测 291\n8.5 生成树 293\n8.6 连通性 297\n8.6.1 无向图的连通性 297\n8.6.2 有向图的连通性 300\n8.7 拓扑排序 302\n8.8 网络 303\n8.8.1 最大流 303\n8.8.2 最小代价的最大流量 311\n8.9 匹配 313\n8.9.1 稳定匹配问题 318\n8.9.2 分配问题 319\n8.9.3 非二部图中的匹配 321\n8.10 欧拉图和哈密顿图 322\n8.10.1 欧拉图 322\n8.10.2 哈密顿图 324\n8.11 图的着色 329\n8.12 图论中的np完整性问题 331\n8.12.1 团问题 331\n8.12.2 3色问题 332\n8.12.3 顶点覆盖问题 333\n8.12.4 哈密顿回路问题 333\n8.13 示例学习：典型代表问题 335\n8.14 习题 336\n8.15 编程作业 345\n参考文献 346\n第9章 排序 349\n9.1 基本排序算法 350\n9.1.1 插入排序 350\n9.1.2 选择排序 352\n9.1.3 冒泡排序 353\n9.2 决策树 355\n9.3 高效排序算法 357\n9.3.1 shell排序 357\n9.3.2 堆排序 360\n9.3.3 快速排序 363\n9.3.4 归并排序 367\n9.3.5 基数排序 370\n9.4 java.util中的排序 373\n9.5 总结 375\n9.6 示例学习：多项式加法 376\n9.7 习题 383\n9.8 编程作业 384\n参考文献 384\n第10章 散列 387\n10.1 散列函数 387\n10.1.1 除法 387\n10.1.2 折叠法 388\n10.1.3 平方取 泻　?388\n10.1.4 提取方法 388\n10.1.5 基数变换 388\n10.2 冲突解决 389\n10.2.1 开放定址法 389\n10.2.2 链 393\n10.2.3 桶定址法 394\n10.3 删除 394\n10.4 完全散列函数 395\n10.4.1 cichelli方法 396\n10.4.2 fhcd算法 398\n10.5 可扩展文件的散列函数 400\n10.5.1 可扩展散列 400\n10.5.2 线性散列 402\n10.6 java.util中的散列 404\n10.6.1 hashmap 404\n10.6.2 hashset 407\n10.6.3 hashtable 410\n10.7 示例学习：桶散列 414\n10.8 习题 421\n10.9 编程作业 422\n参考文献 423\n第11章 数据压缩 425\n11.1 数据压缩的条件 425\n11.2 赫夫曼编码 426\n11.3 顺串长度编码 436\n11.4 ziv-lempel编码 437\n11.5 示例学习：结合顺串长度编码的 赫夫曼方法 439\n11.6 习题 448\n11.7 编程作业 448\n参考文献 449\n第12章 存储管理 451\n12.1 顺序适配方法 451\n12.2 非顺序适配算法 452\n12.3 无用单元收集 459\n12.3.1 标记和清除算法 459\n12.3.2 复制方法 465\n12.3.3 增量式无用单元收集 466\n12.4 总结 471\n12.5 示例学习：内置无用单元收集器 472\n12.6 习题 473\n12.7 编程作业 479\n参考文献 481\n第13章 字符串匹配 484\n13.1 精确字符串匹配 484\n13.1.1 直接匹配算法 484\n13.1.2 knuth-morris-pratt算法 486\n13.1.3 boyer-moore算法 492\n13.1.4 多路查找 500\n13.1.5 面向位方法 501\n13.1.6 词匹配集 504\n13.1.7 正则表达式匹配 510\n13.1.8 后缀检索树和树 513\n13.1.9 后缀数组 517\n13.2 近似字符串匹配 518\n13.2.1 字符串相似度 519\n13.2.2 k误配的字符串匹配 524\n13.3 示例学习：最长公共子字符串 526\n13.4 习题 533\n13.5 编程作业 535\n参考文献 535\n附录a 大o的计算 537\na.1 谐波级数 537\na.2 函数lg (n!) 的近似 537\na.3 快速排序平均情况的大o 538\na.4 随机二叉树中的平均路径长度 540\na.5 avl树中的节点数量 541\n附录b np完整性 542\n索引 554', '1886305', 'https://img3.doubanio.com/view/subject/m/public/s1828304.jpg', '7111189930', '9787111189930', '573', '59.00元', '2006-7', '机械工业出版社', 'Java语言版', '本书系统讲解数据结构和算法，并分析了算法的复杂性。本书选择Jaya语言以面向对象的方式描述数据结构，还特别强调了封装和分解的信息隐藏原理。主要内容包括：面向对象编程的基本原理，判定算法效率的方法，堆栈、队列及其应用，对于多种递归的详细讨论，二叉树、B树、2-4树等的查找和遍历等，分析排序、散列等数据结构的应用，图、NP完整性，数据压缩算法、存储管理技术以及自动机理论和字符串匹配等算法。　　本书适合作为高等院校计算机专业的教材，也是计算机算法方面的重要参考书。', '数据结构;Java;算法;《数据结构和算法》Java版;计算机;算法&数据结构;编程;编程学习;', '[\"周翔\"]', 'https://api.douban.com/v2/book/1886305');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/1943128/', 'How Tomcat Works', '[\"Budi Kurniawan\",\"Paul Deck\"]', 'Paperback', '', '1943128', 'https://img1.doubanio.com/view/subject/m/public/s4888007.jpg', '097521280X', '9780975212806', '458', 'USD 54.95', '2004-4-1', 'BrainySoftware', 'A Guide to Developing Your Own Java Servlet Container', 'A Guide to Developing Your Own Java Servlet Container', 'Tomcat;java;服务器开源;Server;Java;Web开发;计算机;web;', '[]', 'https://api.douban.com/v2/book/1943128');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/19969386/', 'Java程序性能优化', '[\"葛一鸣\"]', '平装', '第1章 Java性能调优概述\n1.1 性能概述\n1.1.1 看懂程序的性能\n1.1.2 性能的参考指标\n1.1.3 木桶原理与性能瓶颈\n1.1.4 Amdahl定律\n1.2 性能调优的层次\n1.2.1 设计调优\n1.2.2 代码调优\n1.2.3 JVM调优\n1.2.4 数据库调优\n1.2.5 操作系统调优\n1.3 基本调优策略和手段\n1.3.1 优化的一般步骤\n1.3.2 系统优化注意事项\n1.4 小结\n第2章 设计优化\n2.1 善用设计模式\n2.1.1 单例模式\n2.1.2 代理模式\n2.1.3 享元模式\n2.1.4 装饰者模式\n2.1.5 观察者模式\n2.1.6 Value Object模式\n2.1.7 业务代理模式\n2.2 常用优化组件和方法\n2.2.1 缓冲（Buffer）\n2.2.2 缓存（Cache）\n2.2.3 对象复用——“池”\n2.2.4 并行替代串行\n2.2.5 负载均衡\n2.2.6 时间换空间\n2.2.7 空间换时间\n2.3 小结\n第3章 Java程序优化\n3.1 字符串优化处理\n3.1.1 String对象及其特点\n3.1.2 subString()方法的内存泄漏\n3.1.3 字符串分割和查找\n3.1.4 StringBuffer和StringBuilder\n3.2 核心数据结构\n3.2.1 List接口\n3.2.2 Map接口\n3.2.3 Set接口\n3.2.4 优化集合访问代码\n3.2.5 RandomAccess接口\n3.3 使用NIO提升性能\n3.3.1 NIO的Buffer类族和Channel\n3.3.2 Buffer的基本原理\n3.3.3 Buffer的相关操作\n3.3.4 MappedByteBuffer性能评估\n3.3.5 直接内存访问\n3.4 引用类型\n3.4.1 强引用\n3.4.2 软引用\n3.4.3 弱引用\n3.4.4 虚引用\n3.4.5 WeakHashMap类及其实现\n3.5 有助于改善性能的技巧\n3.5.1 慎用异常\n3.5.2 使用局部变量\n3.5.3 位运算代替乘除法\n3.5.4 替换switch\n3.5.5 一维数组代替二维数组\n3.5.6 提取表达式\n3.5.7 展开循环\n3.5.8 布尔运算代替位运算\n3.5.9 使用arrayCopy ()\n3.5.10 使用Buffer进行I/O操作\n3.5.11 使用clone()代替new\n3.5.12 静态方法替代实例方法\n3.6 小结\n第4章 并行程序开发及优化\n4.1 并行程序设计模式\n4.1.1 Future模式\n4.1.2 Master-Worker模式\n4.1.3 Guarded Suspension模式\n4.1.4 不变模式\n4.1.5 生产者-消费者模式\n4.2 JDK多任务执行框架\n4.2.1 无限制线程的缺陷\n4.2.2 简单的线程池实现\n4.2.3 Executor框架\n4.2.4 自定义线程池\n4.2.5 优化线程池大小\n4.2.6 扩展ThreadPoolExecutor\n4.3 JDK并发数据结构\n4.3.1 并发List\n4.3.2 并发Set\n4.3.3 并发Map\n4.3.4 并发Queue\n4.3.5 并发Deque\n4.4 并发控制方法\n4.4.1 Java内存模型与volatile\n4.4.2 同步关键字synchronized\n4.4.3 ReentrantLock重入锁\n4.4.4 ReadWriteLock读写锁\n4.4.5 Condition对象\n4.4.6 Semaphore信号量\n4.4.7 ThreadLocal线程局部变量\n4.5 “锁”的性能和优化\n4.5.1 线程的开销\n4.5.2 避免死锁\n4.5.3 减小锁持有时间\n4.5.4 减小锁粒度\n4.5.5 读写分离锁来替换独占锁\n4.5.6 锁分离\n4.5.7 重入锁ReentrantLock和内部锁synchronized\n4.5.8 锁粗化(Lock Coarsening)\n4.5.9 自旋锁（Spinning Lock）\n4.5.10 锁消除（Lock Elimination）\n4.5.11 锁偏向(Biased Lock)\n4.6 无锁的并行计算\n4.6.1 非阻塞的同步/无锁\n4.6.2 原子操作\n4.6.3 Amino框架介绍\n4.6.4 Amino集合\n4.6.5 Amino树\n4.6.6 Amino图\n4.6.7 Amino简单调度模式\n4.7 协程\n4.7.1 协程的概念\n4.7.2 Kilim框架简介\n4.7.3 Task及其状态\n4.7.4 Fiber及其状态\n4.7.5 Kilim开发环境配置\n4.7.6 Kilim之Hello World\n4.7.7 多任务通信\n4.7.8 Kilim实例及性能评估\n4.8 小结\n第5章 JVM调优\n5.1 Java虚拟机内存模型\n5.1.1 程序计数器\n5.1.2 Java虚拟机栈\n5.1.3 本地方法栈\n5.1.4 Java堆\n5.1.5 方法区\n5.2 JVM内存分配参数\n5.2.1 设置最大堆内存\n5.2.2 设置最小堆内存\n5.2.3 设置新生代\n5.2.4 设置持久代\n5.2.5 设置线程桟\n5.2.6 堆的比例分配\n5.2.7 堆分配参数总结\n5.3 垃圾收集基础\n5.3.1 垃圾收集的作用\n5.3.2 垃圾回收算法与思想\n5.3.3 垃圾收集器的类型\n5.3.4 评价GC策略的指标\n5.3.5 新生代串行收集器\n5.3.6 老年代串行收集器\n5.3.7 并行收集器\n5.3.8 新生代并行回收（Parallel Scavenge）收集器\n5.3.9 老年代并行回收收集器\n5.3.10 CMS收集器\n5.3.11 G1收集器（Garbage First）\n5.3.12 Stop the World案例\n5.3.13 收集器对系统性能的影响\n5.3.14 GC相关参数总结\n5.4 常用调优案例和方法\n5.4.1 将新对象预留在新生代\n5.4.2 大对象进入老年代\n5.4.3 设置对象进入老年代的年龄\n5.4.4 稳定与震荡的堆大小\n5.4.5 吞吐量优先案例\n5.4.6 使用大页案例\n5.4.7 降低停顿案例\n5.5 实用JVM参数\n5.5.1 JIT编译参数\n5.5.2 堆快照（堆Dump）\n5.5.3 错误处理\n5.5.4 取得GC信息\n5.5.5 类和对象跟踪\n5.5.6 控制GC\n5.5.7 选择类校验器\n5.5.8 Solaris下线程控制\n5.5.9 使用大页\n5.5.10 压缩指针\n5.6 实战JVM调优\n5.6.1 Tomcat简介与启动加速\n5.6.2 Web应用程序介绍\n5.6.3 JMeter介绍与使用\n5.6.4 调优前Web应用运行状况\n5.6.5 调优过程\n5.7 总结\n第6章 Java性能调优工具\n6.1 Linux命令行工具\n6.1.1 top命令\n6.1.2 sar命令\n6.1.3 vmstat命令\n6.1.4 iostat命令\n6.1.5 pidstat工具\n6.2 Windows工具\n6.2.1 任务管理器\n6.2.2 perfmon性能监控工具\n6.2.3 Process Explorer\n6.2.4 pslist命令行\n6.3 JDK命令行工具\n6.3.1 jps命令\n6.3.2 jstat命令\n6.3.3 jinfo命令\n6.3.4 jmap命令\n6.3.5 jhat命令\n6.3.6 jstack命令\n6.3.7 jstatd命令\n6.3.8 hprof工具\n6.4 JConsole工具\n6.4.1 JConsole连接Java程序\n6.4.2 Java程序概况\n6.4.3 内存监控\n6.4.4 线程监控\n6.4.5 类加载情况\n6.4.6 虚拟机信息\n6.4.7 MBean管理\n6.4.8 使用插件\n6.5 Visual VM多合一工具\n6.5.1 Visual VM连接应用程序\n6.5.2 监控应用程序概况\n6.5.3 Thread Dump和分析\n6.5.4 性能分析\n6.5.5 快照\n6.5.6 内存快照分析\n6.5.7 MBean管理\n6.5.8 TDA使用\n6.5.9 BTrace介绍\n6.6 Visual VM对OQL的支持\n6.6.1 Visual VM的OQL基本语法\n6.6.2 内置heap对象\n6.6.3 对象函数\n6.6.4 集合/统计函数\n6.6.5 程序化OQL\n6.7 MAT内存分析工具\n6.7.1 初识MAT\n6.7.2 浅堆和深堆\n6.7.3 支配树（Dominator Tree）\n6.7.4 垃圾回收根\n6.7.5 内存泄露检测\n6.7.6 最大对象报告\n6.7.7 查找支配者\n6.7.8 线程分析\n6.7.9 集合使用情况分析\n6.7.10 扩展MAT\n6.8 MAT对OQL的支持\n6.8.1 Select子句\n6.8.2 From子句\n6.8.3 Where子句\n6.8.4 内置对象与方法\n6.9 JProfile简介\n6.9.1 JProfile使用配置\n6.9.2 内存视图\n6.9.3 堆快照\n6.9.4 CPU视图\n6.9.5 线程视图\n6.9.6 JVM统计信息\n6.9.7 触发器\n6.10 小结', '19969386', 'https://img1.doubanio.com/view/subject/m/public/s25101909.jpg', '7302296251', '9787302296256', '416', '59.00元', '2012-9-1', '清华大学出版社', '让你的Java程序更快、更稳定', 'Java是目前应用最为广泛的软件开发平台，学习针对Java程序的优化方法有重要的现实意义。《Java程序性能优化：让你的Java程序更快、更稳定》以Java性能调优为主线，系统地阐述了与Java性能优化相关的知识与技巧。\n《Java程序性能优化：让你的Java程序更快、更稳定》共6章，先后从软件设计、软件编码、JVM调优以及程序故障排斥等方面介绍针对Java程序的优化方法。第1章介绍性能的基本概念、定律、系统调优的过程和注意事项。第2章从设计层面介绍与性能相关的设计模式、组件。第3章从代码层面介绍如何编写高性能的Java程序。第4章介绍了并行开发和如何通过多线程提高系统性能。第5章立足于JVM虚拟机层面，介绍如何通过设置合理的JVM参数提升Java程序的性能。第6章为工具篇，介绍了获取和监控程序或系统性能指标的各种工具，包括相关的故障排查工具。\n本书适合所有Java程序员、软件设计师、架构师以及软件开发爱好者，对于有一定经验的Java工程师，本书更能帮助他突破技术瓶颈，深入Java内核开发！', 'Java;性能优化;性能;java;编程;计算机;程序设计;优化;', '[]', 'https://api.douban.com/v2/book/19969386');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/2000732/', 'Head First Java（第二版·中文版）', '[\"Kathy Sierra,Bert Bates 著\",\"杨尊一 编译 张然等 改编\"]', '16开', '序\n1 进入Java的世界\nJava的工作方式\nJava的程序结构\n剖析类\nmain（）方法\n循环\n条件分支\n设计程序\n术语制造机\n谈话录\n习题\n2 拜访对象村\n椅子大战\n继承\n覆盖\n什么是类？\n创建你的第一个对象\n使用main（）\n猜数字\n习题\n3 认识变量\n声明变量\nPrimitive主数据类型\nJava关键字\n引用变量\n对象的声明与赋值\n可回收堆空间\n数组\n习题\n4 对象的行为\n操作对象状态的方法\n方法参数与返回类型\n值传递\nGetters与Setters\n封装\n数组中的引用\n习题\n5 超强力方法\n创建战舰游戏\n简单版\n编写伪码\n测试\n编写程序\n完成版\n用Math.random（）产生随机数\n预先输入好的程序\n循环\n类型转换\n用Integer.parseInt（）转换字符串\n习题\n6 使用Java函数库\n7 对象村的优质生活\n8 深入多态\n9 对象的前世今生\n10 数字很重要\n11 有风险的行为\n12 看图说故事\n13 使用Swing\n14 保存对象\n15 网络联机\n16 数据结构\n17 发布程序\n18 分布式计算\n附录A：程序料理决定版\n附录B：十大遗珠之憾\n索引', '2000732', 'https://img3.doubanio.com/view/subject/m/public/s2171906.jpg', '7508344987', '9787508344980', '600', '79.00元', '2007-2', '中国电力出版社', '', '《Head First Java》是本完整的面向对象（object-oriented，OO）程序设计和Java的学习指导。此书是根据学习理论所设计的，让你可以从学习程序语言的基础开始一直到包括线程、网络与分布式程序等项目。最重要的，你会学会如何像个面向对象开发者一样去思考。\n而且不只是读死书，你还会玩游戏、拼图、解谜题以及以意想不到的方式与Java交互。在这些活动中，你会写出一堆真正的Java程序，包括了一个船舰炮战游戏和一个网络聊天程序。\nHead First系列的图文并茂学习方式能让你快速地在脑海中掌握住知识。敞开心胸准备好学习这些关键性的主题：\n*Java程序语言\n*面向对象程序开发\n*Swing图形化接口\n*使用Java API函数库\n*编写、测试与布署应用程序\n*处理异常\n*多线程\n*网络程序设计\n*集合与泛型\n如果你想要看“一本正经”的书，去找其他的。但如果你真地想要好好地学习Java，你会需要《Head First Java》。这本书可是Amazon编辑推荐的十大好书之一！', 'java;编程;HeadFirst;Java;计算机;程序设计;软件开发;计算机语言;', '[\"杨尊一\"]', 'https://api.douban.com/v2/book/2000732');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/2130190/', 'Java编程思想 （第4版）', '[\"[美] Bruce Eckel\"]', '平装', '读者评论\n前言\n简介\n第1章 对象导论\n1.1 抽象过程\n1.2 每个对象都有一个接口\n1.3 每个对象都提供服务\n1.4 被隐藏的具体实现\n1.5 复用具体实现\n1.6 继承\n1.6.1 “是一个”（is-a）与“像是一个”（is-like-a）关系\n1.7 伴随多态的可互换对象\n1.8 单根继承结构\n1.9 容器\n1.9.1 参数化类型（范型）\n1.10 对象的创建和生命期\n1.11 异常处理：处理错误\n1.12 并发编程\n1.13 Java与Internet\n1.13.1 Web是什么\n1.13.2 客户端编程\n1.13.3 服务器端编程\n1.22 总结\n第2章 一切都是对象\n2.1 用引用操纵对象\n2.2 必须由你创建所有对象\n2.2.1 存储到什么地方\n2.2.2 特例：基本类型\n2.2.3 Java中的数组\n2.3 永远不需要销毁对象\n2.3.1 作用域\n2.3.2 对象的作用域\n2.4 创建新的数据类型：类\n2.4.1 域和方法\n2.4.2 基本成员默认值\n2.5 方法、参数和返回值\n2.5.1 参数列表\n2.6 构建一个Java程序\n2.6.1 名字可见性\n2.6.2 运用其他构件\n2.6.3 static 关键字\n2.7 你的第一个Java程序\n编译和运行\n2.8 注释和嵌入式文档\n2.8.1 注释文档\n2.8.2 语法\n2.8.3 嵌入式HTML\n2.8.4 一些标签示例\n2.8.5 文档示例\n2.9 编码风格\n2.10 总结\n2.11 练习\n第3章 操作符\n3.1 更简单的打印语句\n3.2 使用Java操作符\n3.3 优先级\n3.4 赋值\n3.4.1 方法调用中的别名问题\n3.5 算术操作符\n3.5.1 一元加、减操作符\n3.6 自动递增和递减\n3.7 关系操作符\n3.7.1 测试对象的等价性\n3.8 逻辑操作符\n3.8.1 短路\n3.9 直接常量\n3.9.1 指数记数法\n3.10 按位操作符\n3.11 移位操作符\n3.12 三元操作符 if-else\n3.13 字符串操作符 + 和 +=\n3.14 使用操作符时常犯的错误\n3.15 类型转换操作符\n3.15.1 截尾和舍入\n3.15.2提升\n3.16 Java没有“sizeof”\n3.17 操作符小结\n3.18 总结\n第4章 控制执行流程\n4.1 true和false\n4.2 if-else\n4.3 迭代\n4.3.1 do-while\n4.3.2 for\n4.3.3 逗号操作符\n4.4 Foreach语法\n4.5 return\n4.6 break和 continue\n4.7 臭名昭著的“goto”\n4.8 switch\n4.9 总结\n第5章 初始化与清理\n5.1 用构造器确保初始化\n5.2 方法重载\n5.2.1 区分重载方法\n5.2.2 涉及基本类型的重载\n5.2.3 以返回值区分重载方法\n5.3 缺省构造器\n5.4 this关键字\n5.4.1 在构造器中调用构造器\n5.4.2 static的含义\n5.5 清理：终结处理和垃圾回收\n5.5.1 finalize()的用途何在\n5.5.2 你必须实施清理\n5.5.3 终结条件\n5.5.4 垃圾回收器如何工作\n5.6 成员初始化\n5.6.1 指定初始化\n5.7 构造器初始化\n5.7.1 初始化顺序\n5.7.2. 静态数据的初始化\n5.7.3. 显式的静态初始化\n5.7.4. 非静态实例初始化\n5.8 数组初始化\n5.8.1 可变参数列表\n5.9 枚举类型\n5.10 总结\n第6章 访问权限控制\n第7章 复用类\n第8章 多态\n第9章 接口\n第10章 内部类\n第11章 持有对象\n第12章 通过异常处理错误\n第13章 字符串\n第14章 类型信息\n第15章 泛型\n第16章 数组\n第17章 容器深入研究\n第18章 Java I/O系统\n第19章 枚举类型\n第20章 注解\n第21章 并发\n第22章 图形化用户界面\n附录A 补充材料\n可下载的补充材料\nThinking in C：Java的基础\nJava编程思想 研讨课\nHands-on Java研讨课CD\nThinking in Objects研讨课\nThinking in Enterprise Java\nThinking in Patterns(with Java)\nThinking in Patterns研讨课\n设计咨询与复审\n附录B 资源\n软件\n编辑器与IDE\n书籍\n分析与设计\nPython\n我的著作列表\n索引', '2130190', 'https://img3.doubanio.com/view/subject/m/public/s27243455.jpg', '7111213823', '9787111213826', '880', '108.00元', '2007-6', '机械工业出版社', '', '本书赢得了全球程序员的广泛赞誉，即使是最晦涩的概念，在Bruce Eckel的文字亲和力和小而直接的编程示例面前也会化解于无形。从Java的基础语法到最高级特性（深入的面向对象概念、多线程、自动项目构建、单元测试和调试等），本书都能逐步指导你轻松掌握。\n从本书获得的各项大奖以及来自世界各地的读者评论中，不难看出这是一本经典之作。本书的作者拥有多年教学经验，对C、C++以及Java语言都有独到、深入的见解，以通俗易懂及小而直接的示例解释了一个个晦涩抽象的概念。本书共22章，包括操作符、控制执行流程、访问权限控制、复用类、多态、接口、通过异常处理错误、字符串、泛型、数组、容器深入研究、Java I/O系统、枚举类型、并发以及图形化用户界面等内容。这些丰富的内容，包含了Java语言基础语法以及高级特性，适合各个层次的Java程序员阅读，同时也是高等院校讲授面向对象程序设计语言以及Java语言的绝佳教材和参考书。\n第4版特点：\n适合初学者与专业人员的经典的面向对象叙述方式，为更新的Java SE5/6增加了新的示例和章节。\n 测验框架显示程序输出。', 'Java;编程思想;编程;TinkingInJava;计算机;程序设计;经典;软件开发;', '[\"陈昊鹏\"]', 'https://api.douban.com/v2/book/2130190');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/21661495/', 'Clojure编程', '[\"Chas Emerick\",\"Brian Carper\",\"Christophe Grand\"]', '平装', '第1章  进入Clojure仙境	1\n为什么要选择Clojure?	1\n获取Clojure	3\nClojure REPL	3\n不！括号真的不会让你瞎了眼	6\n表达式、操作符、语法以及优先级	7\n同像性	10\nClojure Reader	12\n命名空间	21\n符号解析	23\n特殊形式	24\n小结	46\n这只是开始	48\n第1部分 	49\n第2章   函数式编程	51\n所谓函数式编程，到底意味着什么？	52\n谈谈值的重要性	52\n作为头等公民的函数以及高阶函数	59\n函数（功能）的组合	68\n纯函数	76\n现实生活中的函数式编程	80\n第3章  集合类与数据结构	83\n抽象优于实现	84\n访问集合元素的简洁方式	111\n数据结构的类型	115\n不可变性和持久性	123\n元数据	136\n用Clojure的集合来小试牛刀	137\n总结	159\n第4章  多线程和并发	161\n计算在时间和空间内的转换	162\n简单的并行化	168\n状态和标识	170\nClojure的引用类型	172\n并发操作的分类	174\n原子类型（Atom）	176\n通知和约束	179\nref	182\nvar	200\nAgent	211\n使用Java的并发原语	227\n总结	228\n第2部分 	229\n第5 章  宏	231\n宏到底是什么？	231\n编写你的第一个宏	237\n调试宏	239\n语法	242\n什么时候使用宏	245\n宏卫生	247\n宏的常见用法和模式	253\n隐藏参数：&env 和 &form	255\n深入 -> 和 ->>	263\n总结	266\n第6章  数据类型和协议	267\n协议（Protocol）	268\n扩展已有的类型	270\n定义你自己的类型	274\n实现协议	284\n协议自省	293\n协议函数分派的边界场景	295\n自己实现一个set	296\n总结	304\n第7章  多重方法	305\n多重方法基础	305\n通往层级之路	308\n层级	310\n真正实现多重！	315\n还有几件事	317\n最后的思考	321\n第3 部分 	323\n第8章  Clojure项目的组织与构建	325\n项目布局	325\n构建	339\n最后的思考	355\n第9章  Java及JVM互操作	357\nJVM是Clojure的基础	358\nJava类、方法和字段的使用	358\n便利的互操作工具	361\n异常与错误处理	363\n为了效率进行类型提示	367\n定义类、实现接口	372\n在Java里使用Clojure	386\n乐于合作的伙伴	393\n第10章  面向REPL的编程	395\n交互式开发	395\n工具集	400\n在REPL里调试、监测和打补丁	412\n重定义结构的限制	416\n小结	418\n第4部分 	419\n第11章  数字与数学	421\nClojure的数字	421\nClojure数学	427\n相等与等值	432\n优化数值效率	436\n用Clojure可视化芒德布罗集	448\n第12章  设计模式	457\n依赖注入	459\n策略模式	462\n责任链	463\n面向方面的编程	466\n最后的思考	470\n第13章  测试	471\n不可变值与纯函数	471\nclojure.test	473\nHTML DSL的成长	482\n依赖断言	486\n第14章  使用关系数据库	491\nclojure.java.jdbc	491\nKorma	498\nHibernate	503\n最后的思考	510\n第15章  使用非关系型数据库	511\n安装CouchDB和Clutch	512\n基本的CRUD操作	512\n视图	513\n_changes: 把CouchDB滥用做消息队列	519\n可随意点选的消息队列	521\n最后的思考	524\n第16章  Clojure与Web	525\nClojure栈	525\n基石：Ring	526\n用Compojure路由请求	533\n使用模板	543\n最后的思考	552\n第17章  布署Clojure Web应用程序	553\nJava与Clojure Web架构	553\n在本地运行Web应用	561\nWeb应用程序布署	562\n超越简单Web应用程序布署	565\n第5部分 	567\n第18章  明智地选择Clojure类型定义形式	569\n第19章  在工作场所引进Clojure	573\n只是事实…	573\n强调生产效率	574\n强调社群	576\n审慎	577\n第20章  下一步？	579\n(dissoc Clojure ‘JVM)	579\n4Clojure	580\nOvertone	581\ncore.logic	581\nPallet	582\nAvout	582\nHeroku上的Clojure	583\n关于作者	585', '21661495', 'https://img3.doubanio.com/view/subject/m/public/s25803832.jpg', '7121197189', '9787121197185', '618', '99.00元', '2013-3-26', '电子工业出版社', 'Java世界的Lisp实践', 'Clojure是一种实用的通用语言，它是传奇语言LISP的方言，可与Ruby、Python等动态语言相媲美，更以无缝Java库、服务，以及拥有JVM系统得天独厚的资源优势而胜出。本书既可以用来熟悉Clojure基础知识与常见例子，也可了解其相关的实践领域与话题，更可以看到这一JVM平台上的LISP如何帮助消除不必要的复杂性，为大家在编程实践中解决最具挑战性的问题开辟新的选择——更具灵活性，更适于Web编程和操作数据库，可以应付更为苛刻的应用程序安全要求，更有效的并发性和并行处理、数据分析能力，以及在未来云环境下的更大的发展潜力。', 'Clojure;函数式;lisp;编程;Java;programming;程度设计;软件开发;', '[\"徐明明\",\"杨寿勋\"]', 'https://api.douban.com/v2/book/21661495');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/25828043/', 'Java性能优化权威指南', '[\"Charlie Hunt\",\"Binu John\"]', '平装', '第1章　策略、方法和方法论　　1\n1.1 　性能问题的现状　　1\n1.2 　性能分析的两种方法：自顶向下和自底向上　　4\n1.2.1 　自顶向下　　4\n1.2.2 　自底向上　　5\n1.3 　选择正确的平台并评估系统性能　　5\n1.3.1 　选择正确的CPU架构　　6\n1.3.2 　评估系统性能　　7\n1.4 　参考资料　　7\n第2章　操作系统性能监控　　8\n2.1 　定义　　8\n2.2 　CPU使用率　　9\n2.2.1 　监控CPU使用率：Windows　　9\n2.2.2 　监控CPU使用率：Windows typeperf　　12\n2.2.3 　监控CPU使用率：Linux　　13\n2.2.4 　监控CPU使用率：Solaris　　14\n2.2.5 　命令行监控CPU使用率：Linux和Solaris　　16\n2.3 　CPU调度程序运行队列　　19\n2.3.1 　监控CPU调度程序运行队列：Windows　　19\n2.3.2 　监控CPU调度程序运行队列：Solaris　　21\n2.3.3 　监控CPU调度程序运行队列：Linux　　21\n2.4 　内存使用率　　22\n2.4.1 　监控内存利用率：Windows　　22\n2.4.2 　监控内存使用率：Solaris　　23\n2.4.3 　监控内存使用率：Linux　　24\n2.4.4 　监控锁竞争：Solaris　　25\n2.4.5 　监控锁竞争：Linux　　26\n2.4.6 　监控锁竞争：Windows　　27\n2.4.7 　隔离竞争锁　　27\n2.4.8 　监控抢占式上下文切换　　27\n2.4.9 　监控线程迁移　　28\n2.5 　网络I/O使用率　　28\n2.5.1 　监控网络I/O使用率：Solaris　　29\n2.5.2 　监控网络I/O使用率：Linux　　30\n2.5.3 　监控网络I/O使用率：Windows　　30\n2.5.4 　应用性能改进的考虑　　31\n2.6 　磁盘I/O使用率　　31\n2.7 　其他命令行工具　　34\n2.8 　监控CPU使用率：SPARC T系列系统　　35\n2.9 　参考资料　　36\n第3章　JVM概览　　38\n3.1 　HotSpot VM的基本架构　　38\n3.2 　HotSpot VM运行时　　40\n3.2.1 　命令行选项　　40\n3.2.2 　VM生命周期　　41\n3.2.3 　VM类加载　　44\n3.2.4 　字节码验证　　46\n3.2.5 　类数据共享　　47\n3.2.6 　解释器　　48\n3.2.7 　异常处理　　49\n3.2.8 　同步　　50\n3.2.9 　线程管理　　51\n3.2.10 　C++堆管理　　53\n3.2.11 　Java本地接口　　54\n3.2.12 　VM致命错误处理　　55\n3.3 　HotSpot VM垃圾收集器　　56\n3.3.1 　分代垃圾收集　　56\n3.3.2 　新生代　　58\n3.3.3 　快速内存分配　　60\n3.3.4 　垃圾收集器　　60\n3.3.5 　Serial收集器　　61\n3.3.6 　Parallel收集器：吞吐量为先！　　62\n3.3.7　　Mostly-Concurrent收集器：低延迟为先！　　62\n3.3.8　　Garbage-First收集器：CMS替代者　　64\n3.3.9 　垃圾收集器比较　　64\n3.3.10 　应用程序对垃圾收集器的影响　　65\n3.3.11 　简单回顾收集器历史　　65\n3.4 　HotSpot VM JIT编译器　　65\n3.4.1 　类型继承关系分析　　67\n3.4.2 　编译策略　　67\n3.4.3 　逆优化　　68\n3.4.4 　Client JIT编译器概览　　69\n3.4.5 　Server JIT编译器概览　　69\n3.4.6 　静态单赋值——程序依赖图　　69\n3.4.7 　未来增强展望　　71\n3.5 　HotSpot VM自适应调优　　71\n3.5.1 　Java 1.4.2的默认值　　71\n3.5.2 　Java 5自动优化的默认值　　71\n3.5.3 　Java 6 Update 18更新后的默认优化值　　73\n3.5.4 　自适应Java堆调整　　74\n3.5.5 　超越自动优化　　75\n3.6 　参考资料　　75\n第4章　JVM性能监控　　77\n4.1 　定义　　77\n4.2 　垃圾收集　　78\n4.2.1 　重要的垃圾收集数据　　78\n4.2.2 　垃圾收集报告　　78\n4.2.3 　垃圾收集数据的离线分析　　86\n4.2.4 　图形化工具　　89\n4.3 　JIT编译器　　103\n4.4 　类加载　　104\n4.5 　Java应用监控　　106\n4.6 　参考资料　　109\n第5章　Java应用性能分析　　110\n5.1 　术语　　111\n5.1.1 　通用性能分析术语　　111\n5.1.2 　Oracle Solaris Studio Performance Analyzer术语　　112\n5.1.3 　NetBeans Profiler术语　　112\n5.2 　Oracle Solaris Studio Performance Analyzer　　112\n5.2.1 　支持平台　　113\n5.2.2 　下载/安装Oracle Solaris Studio Performance Analyzer　　114\n5.2.3 　使用Oracle Solaris Studio Performance Analyzer 抓取性能数据　　114\n5.2.4 　查看性能数据　　118\n5.2.5 　数据表示　　125\n5.2.6 　过滤性能数据　　128\n5.2.7 　命令行工具er_print　　129\n5.3 　NetBeans Profiler　　135\n5.3.1 　支持平台　　136\n5.3.2 　下载安装NetBeans Profiler　　136\n5.3.3 　开始方法分析会话　　137\n5.3.4 　Controls子面板　　143\n5.3.5 　Status子面板　　143\n5.3.6 　Profiling Results子面板　　143\n5.3.7 　Saved Snapshots子面板　　144\n5.3.8 　View子面板　　144\n5.3.9 　Basic Telemetry子面板　　144\n5.3.10 　查看动态结果　　145\n5.3.11 　对结果进行快照　　145\n5.3.12 　启动内存分析会话　　146\n5.3.13 　查看实时结果　　148\n5.3.14 　对结果进行快照　　150\n5.3.15 　定位内存泄漏　　150\n5.3.16 　分析堆转储　　151\n5.4 　参考资料　　152\n第6章　Java应用性能分析技巧　　153\n6.1 　性能优化机会　　153\n6.2 　系统或内核态CPU使用　　154\n6.3 　锁竞争　　161\n6.4 　Volatile的使用　　171\n6.5 　调整数据结构的大小　　172\n6.5.1 　StringBuilder或StringBuffer大小的调整　　172\n6.5.2 　Java Collection类大小调整　　175\n6.6 　增加并行性　　179\n6.7 　过高的CPU使用率　　181\n6.8 　其他有用的分析提示　　182\n6.9 　参考资料　　184\n第7章　JVM性能调优入门　　185\n7.1 　方法　　185\n7.1.1 　假设条件　　187\n7.1.2 　测试基础设施需求　　188\n7.2 　应用程序的系统需求　　188\n7.2.1 　可用性　　188\n7.2.2 　可管理性　　188\n7.2.3 　吞吐量　　189\n7.2.4 　延迟及响应性　　189\n7.2.5 　内存占用　　189\n7.2.6 　启动时间　　189\n7.3 　对系统需求分级　　190\n7.4 　选择JVM部署模式　　190\n7.4.1 　单JVM部署模式　　190\n7.4.2 　多JVM部署模式　　190\n7.4.3 　通用建议　　191\n7.5 　选择JVM运行模式　　191\n7.5.1 　Client模式或Server模式　　191\n7.5.2 　32位/64位 JVM　　192\n7.5.3 　垃圾收集器　　192\n7.6 　垃圾收集调优基础　　193\n7.6.1 　性能属性　　193\n7.6.2 　原则　　193\n7.6.3 　命令行选项及GC日志　　194\n7.7 　确定内存占用　　197\n7.7.1 　约束　　197\n7.7.2 　HotSpot VM堆的布局　　197\n7.7.3 　堆大小调优着眼点　　200\n7.7.4 　计算活跃数据大小　　201\n7.7.5 　初始堆空间大小配置　　202\n7.7.6 　其他考量因素　　203\n7.8 　调优延迟/响应性　　204\n7.8.1 　输入　　205\n7.8.2 　优化新生代的大小　　205\n7.8.3 　优化老年代的大小　　207\n7.8.4 　为CMS调优延迟　　210\n7.8.5 　Survivor空间介绍　　212\n7.8.6 　解析晋升阈值　　214\n7.8.7 　监控晋升阈值　　215\n7.8.8 　调整Survivor空间的容量　　216\n7.8.9 　显式的垃圾收集　　222\n7.8.10 　并发永久代垃圾收集　　223\n7.8.11 　调优CMS停顿时间　　224\n7.8.12 　下一步　　225\n7.9 　应用程序吞吐量调优　　225\n7.9.1 　CMS吞吐量调优　　225\n7.9.2 　Throughput收集器调优　　226\n7.9.3 　Survivor空间调优　　228\n7.9.4 　调优并行垃圾收集线程　　231\n7.9.5 　在NUMA系统上部署　　231\n7.9.6 　下一步　　232\n7.10 　极端示例　　232\n7.11 　其他性能命令行选项　　232\n7.11.1 　实验性（最近最大）优化　　232\n7.11.2 　逃逸分析　　233\n7.11.3 　偏向锁　　233\n7.11.4 　大页面支持　　234\n7.12 　参考资料　　236\n第8章　Java应用的基准测试　　237\n8.1 　基准测试所面临的挑战　　237\n8.1.1 　基准测试的预热阶段　　238\n8.1.2 　垃圾收集　　240\n8.1.3 　使用Java Time接口　　240\n8.1.4 　剔除无效代码　　241\n8.1.5 　内联　　247\n8.1.6 　逆优化　　251\n8.1.7 　创建微基准测试的注意事项　　256\n8.2 　实验设计　　257\n8.3 　使用统计方法　　258\n8.3.1 　计算均值　　258\n8.3.2 　计算标准差　　258\n8.3.3 　计算置信区间　　259\n8.3.4 　使用假设测试　　260\n8.3.5 　使用统计方法的注意事项　　262\n8.4 　参考文献　　263\n8.5 　参考资料　　263\n第9章　多层应用的基准测试　　264\n9.1 　基准测试难题　　264\n9.2 　企业级应用基准测试的考量　　266\n9.2.1 　定义被测系统　　266\n9.2.2 　制定微基准测试　　266\n9.2.3 　定义用户交互模型　　267\n9.2.4 　定义性能指标　　270\n9.2.5 　扩展基准测试　　273\n9.2.6 　用利特尔法则验证　　274\n9.2.7 　思考时间　　275\n9.2.8 　扩展性分析　　278\n9.2.9 　运行基准测试　　278\n9.3 　应用服务器监控　　281\n9.3.1 　GlassFish监控　　281\n9.3.2 　监控子系统　　286\n9.3.3 　Solaris　　287\n9.3.4 　Linux　　288\n9.3.5 　Windows　　288\n9.3.6 　外部系统的性能　　289\n9.3.7 　磁盘I/O　　292\n9.3.8 　监控和调优资源池　　293\n9.4 　企业级应用性能分析　　294\n9.5 　参考资料　　295\n第10章　Web应用的性能调优　　297\n10.1 　Web应用的基准测试　　298\n10.2 　Web容器的组件　　298\n10.2.1 　HTTP连接器　　299\n10.2.2 　Servlet引擎　　300\n10.3 　Web容器的监控和性能调优　　300\n10.3.1 　容器的开发和生产模式　　300\n10.3.2 　安全管理器　　301\n10.3.3 　JVM调优　　301\n10.3.4 　HTTP服务和Web容器　　303\n10.3.5 　HTTP监听器　　303\n10.4 　最佳实践　　315\n10.4.1 　Servlet和JSP最佳实践　　315\n10.4.2 　内容缓存　　324\n10.4.3 　会话持久化　　328\n10.4.4 　HTTP服务器文件缓存　　329\n10.5 　参考资料　　333\n第11章　Web Service的性能　　334\n11.1 　XML的性能　　334\n11.1.1 　XML处理的生命周期　　335\n11.1.2 　解析/解编组　　335\n11.1.3 　访问　　338\n11.1.4 　修改　　338\n11.1.5 　序列化/编组　　339\n11.2 　验证　　339\n11.3 　解析外部实体　　341\n11.4 　XML文档的局部处理　　343\n11.5 　选择合适的API　　346\n11.6 　JAX-WS参考实现栈　　349\n11.7 　Web Service基准测试　　350\n11.8 　影响Web Service性能的因素　　353\n11.8.1 　消息大小的影响　　353\n11.8.2 　不同Schema类型的性能特征　　355\n11.8.3 　终端服务器的实现　　358\n11.8.4 　处理程序的性能　　359\n11.9 　最佳性能实践　　361\n11.9.1 　二进制负载的处理　　361\n11.9.2 　处理XML文档　　365\n11.9.3 　使用MTOM发送XML文档　　365\n11.9.4 　使用Provider接口　　368\n11.9.5 　快速信息集　　370\n11.9.6 　HTTP压缩　　372\n11.9.7 　Web Service客户端的性能　　373\n11.10 　参考资料　　374\n第12章　Java持久化及Enterprise Java Bean的性能　　375\n12.1 　EJB编程模型　　376\n12.2 　Java持久化API及其参考实现　　376\n12.3 　监控及调优EJB容器　　379\n12.3.1 　线程池　　380\n12.3.2 　Bean池和缓存　　382\n12.3.3 　EclipseLink会话缓存　　385\n12.4 　事务隔离级　　386\n12.5 　Enterprise Java Bean的最佳实践　　387\n12.5.1 　简要说明使用的EJB基准测试　　387\n12.5.2 　EJB 2.1　　388\n12.5.3 　EJB 3.0　　400\n12.6 　Java持久化最佳实践　　403\n12.6.1 　JPA查询语言中的查询　　403\n12.6.2 　查询结果缓存　　405\n12.6.3 　FetchType　　406\n12.6.4 　连接池　　408\n12.6.5 　批量更新　　409\n12.6.6 　选择正确的数据库锁策略　　411\n12.6.7 　不带事务的读取　　411\n12.6.8 　继承　　411\n12.7 　参考资料　　412\n附录A 　重要的HotSpot VM选项　　413\n附录B 　性能分析技巧示例源代码　　429\nB.1 　锁竞争实现1　　429\nB.2 　锁竞争实现2　　439\nB.3 　锁竞争实现3　　449\nB.4 　锁竞争实现4　　459\nB.5 　锁竞争实现5　　469\nB.6 　调整容量变化1　　481\nB.7 　调整容量变化2　　492\nB.8 　增加并发性的单线程实现　　504\nB.9 　增加并发性的多线程实现　　514\n', '25828043', 'https://img1.doubanio.com/view/subject/m/public/s27219217.jpg', '7115342970', '9787115342973', '540', '109.00 元', '2014-3', '人民邮电出版社', 'Java性能优化权威指南', 'Java性能优化圣经！Java之父重磅推荐！\n本书由曾任职于Oracle/Sun的性能优化专家编写，系统而详细地讲解了性能优化的各个方面，帮助你学习Java虚拟机的基本原理、掌握一些监控Java程序性能的工具，从而快速找到程序中的性能瓶颈，并有效改善程序的运行性能。\nJava性能优化的任何问题，都可以从本书中找到答案！', 'Java;性能优化;JVM;性能;java;优化;计算机;编程;', '[\"柳飞\",\"陆明刚\"]', 'https://api.douban.com/v2/book/25828043');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/26593466/', '架构探险――从零开始写Java Web框架', '[\"黄勇\"]', '平装', '第1章 从一个简单的Web应用 1\n正所谓“工欲善其事，必先利其器”，在正式开始设计并开发我们的轻量级Java Web框架之前，有必要首先掌握以下技能：\n使用IDEA搭建并开发Java项目；\n使用Maven自动化构建Java项目；\n使用Git管理项目源代码。\n1.1 使用IDEA创建Maven项目 3\n1.1.1 创建IDEA项目 3\n1.1.2 调整Maven配置 3\n1.2 搭建Web项目框架 5\n1.2.1 转为Java Web项目 5\n1.2.2 添加Java Web的Maven依赖 6\n1.3 编写一个简单的Web应用 10\n1.3.1 编写 Servlet类 10\n1.3.2 编写JSP页面 11\n1.4 让Web应用跑起来 12\n1.4.1 在IDEA中配置Tomcat 12\n1.4.2 使用Tomcat的Maven插件 13\n1.4.3 以Debug方式运行程序 13\n1.5 将代码放入Git仓库中 14\n1.5.1 编写.gitignore文件 14\n1.5.2 提交本地 Git 仓库 15\n1.5.3 推送远程Git仓库 15\n1.5.4 总结 16\n第2章 为Web应用添加业务功能 17\n我们将在这个应用的基础上增加一些业务功能，您将学会更多有关项目实战的技能，具体包括：\n如何进行需求分析；\n如何进行系统设计；\n如何编写应用程序。\n2.1 需求分析与系统设计 19\n2.1.1 需求分析 19\n2.1.2 系统设计 19\n2.2 动手开发Web应用 21\n2.2.1 创建数据库 22\n2.2.2 准备开发环境 22\n2.2.3 编写模型层 23\n2.2.4 编写控制器层 25\n2.2.5 编写服务层 27\n2.2.6 编写单元测试 28\n2.2.7 编写视图层 31\n2.3 细节完善与代码优化 31\n2.3.1 完善服务层 32\n2.3.2 完善控制器层 59\n2.3.3 完善视图层 60\n2.4 总结 65\n第3章 搭建轻量级Java Web框架 66\n我们需要这样的框架，它足够轻量级、足够灵巧，不妨给它取一个优雅的名字——Smart Framework，本章我们就一起来实现这个框架。\n您将通过本章的学习，掌握如下技能：\n如何快速搭建开发框架；\n如何加载并读取配置文件；\n如何实现一个简单的IOC容器；\n如何加载指定的类；\n如何初始化框架。\n3.1 确定目标 68\n3.2 搭建开发环境 70\n3.2.1 创建框架项目 70\n3.2.2 创建示例项目 73\n3.3 定义框架配置项 74\n3.4 加载配置项 75\n3.5 开发一个类加载器 78\n3.6 实现Bean容器 87\n3.7 实现依赖注入功能 90\n3.8 加载Controller 93\n3.9 初始化框架 97\n3.10 请求转发器 98\n3.11 总结 109\n第4章 使框架具备AOP特性 110\n在本章中，读者将学到大量有用的技术，具体包括：\n如何理解并使用代理技术；\n如何使用Spring提供的AOP技术；\n如何使用动态代理技术实现AOP框架；\n如何理解并使用ThreadLocal技术；\n如何理解数据库事务管理机制；\n如何使用AOP框架实现事务控制。\n4.1 代理技术简介 112\n4.1.1 什么是代理 112\n4.1.2 JDK动态代理 114\n4.1.3 CGlib动态代理 116\n4.2 AOP技术简介 118\n4.2.1 什么是AOP 118\n4.2.2 写死代码 119\n4.2.3 静态代理 120\n4.2.4 JDK动态代理 121\n4.2.5 CGLib动态代理 122\n4.2.6 Spring AOP 124\n4.2.7 Spring + AspectJ 136\n4.3 开发AOP框架 142\n4.3.1 定义切面注解 142\n4.3.2 搭建代理框架 143\n4.3.3 加载AOP框架 150\n4.4 ThreadLocal简介 158\n4.4.1 什么是ThreadLocal 158\n4.4.2 自己实现ThreadLocal 161\n4.4.3 ThreadLocal使用案例 163\n4.5 事务管理简介 172\n4.5.1 什么是事务 172\n4.5.2 事务所面临的问题 173\n4.5.3 Spring的事务传播行为 175\n4.6 实现事务控制特性 178\n4.6.1 定义事务注解 178\n4.6.2 提供事务相关操作 181\n4.6.3 编写事务代理切面类 182\n4.6.4 在框架中添加事务代理机制 184\n4.7 总结 185\n第5章 框架优化与功能扩展 186\n本章将对现有框架进行优化，并提供一些扩展功能。通过本章的学习，读者可以了解到：\n如何优化Action参数；\n如何实现文件上传功能；\n如何与Servlet API完全解耦；\n如何实现安全控制框架；\n如何实现Web服务框架。\n5.1 优化Action参数 188\n5.1.1 明确Action参数优化目标 188\n5.1.2 动手优化Action参数使用方式 188\n5.2 提供文件上传特性 191\n5.2.1 确定文件上传使用场景 191\n5.2.2 实现文件上传功能 194\n5.3 与Servlet API解耦 214\n5.3.1 为何需要与Servlet API解耦 214\n5.3.2 与Servlet API解耦的实现过程 215\n5.4 安全控制框架——Shiro 219\n5.4.1 什么是Shiro 219\n5.4.2 Hello Shiro 220\n5.4.3 在Web开发中使用Shiro 224\n5.5 提供安全控制特性 230\n5.5.1 为什么需要安全控制 230\n5.5.2 如何使用安全控制框架 231\n5.5.3 如何实现安全控制框架 242\n5.6 Web服务框架——CXF 261\n5.6.1 什么是CXF 261\n5.6.2 使用CXF开发SOAP服务 262\n5.6.3 基于SOAP的安全控制 278\n5.6.4 使用CXF开发REST服务 291\n5.7 提供Web服务特性 308\n5.8 总结 329\n附录A Maven快速入门 330\n附录B 将构件发布到Maven中央仓库 342', '26593466', 'https://img1.doubanio.com/view/subject/m/public/s28277649.jpg', '7121268299', '9787121268298', '364', '79.00', '2015-8-1', '电子工业出版社', '从零开始写Java Web框架', '本书首先从一个简单的 Web 应用开始，让读者学会如何使用 IDEA、Maven、Git 等开发工具搭建 Java Web 应用；接着通过一个简单的应用场景，为该 Web 应用添加若干业务功能，从需求分析与系统设计开始，带领读者动手完成该 Web 应用，完善相关细节，并对已有代码进行优化；然后基于传统 Servlet 框架搭建一款轻量级 Java Web 框架，一切都是从零开始，逐个实现类加载器、Bean 容器、IoC 框架、MVC 框架，所涉及的代码也是整个框架的核心基础。为了使框架具备 AOP 特性，从代理技术讲到 AOP 技术，从 ThreadLocal 技术讲到事务控制技术。最后对框架进行优化与扩展，通过对现有框架的优化，使其可以提供更加完备的功能，并以扩展 Web 服务插件与安全控制插件为例，教会读者如何设计一款可扩展的Web应用框架。', 'Java;架构;架构设计入门;软件开发;计算机;后端开发;java;计算机科学;', '[]', 'https://api.douban.com/v2/book/26593466');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/2696119/', 'Effective Java: Second Edition', '[\"Joshua Bloch\"]', 'Paperback', 'Foreword\nPreface\nAcknowledgments\n1 Introduction\n2 Creating and Destroying Objects\nItem 1: Consider static factory methods instead of constructors\nItem 2: Consider a builder when faced with many constructor parameters\nItem 3: Enforce the singleton property with a private constructor or an enum type\nItem 4: Enforce noninstantiability with a private constructor\nItem 5: Avoid creating unnecessary objects\nItem 6: Eliminate obsolete object references\nItem 7: Avoid finalizers\n3 Methods Common to All Objects\nItem 8: Obey the general contract when overriding equals\nItem 9: Always override hashCode when you override equals\nItem 10: Always override toString\nItem 11: Override clone judiciously\nItem 12: Consider implementing Comparable\n4 Classes and Interfaces\nItem 13: Minimize the accessibility of classes and members\nItem 14: In public classes, use accessor methods, not public fields\nItem 15: Minimize mutability\nItem 16: Favor composition over inheritance\nItem 17: Design and document for inheritance or else prohibit it\nItem 18: Prefer interfaces to abstract classes\nItem 19: Use interfaces only to define types\nItem 20: Prefer class hierarchies to tagged classes\nItem 21: Use function objects to represent strategies\nItem 22: Favor static member classes over nonstatic\n5 Generics\nItem 23: Don\'t use raw types in new code\nItem 24: Eliminate unchecked warnings\nItem 25: Prefer lists to arrays\nItem 26: Favor generic types\nItem 27: Favor generic methods\nItem 28: Use bounded wildcards to increase API flexibility\nItem 29: Consider typesafe heterogeneous containers\n6 Enums and Annotations\nItem 30: Use enums instead of int constants\nItem 31: Use instance fields instead of ordinals\nItem 32: Use EnumSet instead of bit fields\nItem 33: Use EnumMap instead of ordinal indexing\nItem 34: Emulate extensible enums with interfaces\nItem 35: Prefer annotations to naming patterns\nItem 36: Consistently use the Override annotation\nItem 37: Use marker interfaces to define types\n7 Methods\nItem 38: Check parameters for validity\nItem 39: Make defensive copies when needed\nItem 40: Design method signatures carefully\nItem 41: Use overloading judiciously\nItem 42: Use varargs judiciously\nItem 43: Return empty arrays or collections, not nulls\nItem 44: Write doc comments for all exposed API elements\n8 General Programming\nItem 45: Minimize the scope of local variables\nItem 46: Prefer for-each loops to traditional for loops\nItem 47: Know and use the libraries\nItem 48: Avoid float and double if exact answers are required\nItem 49: Prefer primitive types to boxed primitives\nItem 50: Avoid strings where other types are more appropriate\nItem 51: Beware the performance of string concatenation\nItem 52: Refer to objects by their interfaces\nItem 53: Prefer interfaces to reflection\nItem 54: Use native methods judiciously\nItem 55: Optimize judiciously\nItem 56: Adhere to generally accepted naming conventions\n9 Exceptions\nItem 57: Use exceptions only for exceptional conditions\nItem 58: Use checked exceptions for recoverable conditions and runtime exceptions for programming errors\nItem 59: Avoid unnecessary use of checked exceptions\nItem 60: Favor the use of standard exceptions\nItem 61: Throw exceptions appropriate to the abstraction\nItem 62: Document all exceptions thrown by each method\nItem 63: Include failure-capture information in detail messages\nItem 64: Strive for failure atomicity\nItem 65: Don\'t ignore exceptions\n10 Concurrency\nItem 66: Synchronize access to shared mutable data\nItem 67: Avoid excessive synchronization\nItem 68: Prefer executors and tasks to threads\nItem 69: Prefer concurrency utilities to wait and notify\nItem 70: Document thread safety\nItem 71: Use lazy initialization judiciously\nItem 72: Don\'t depend on the thread scheduler\nItem 73: Avoid thread groups\n11 Serialization\nItem 74: Implement Serializable judiciously\nItem 75: Consider using a custom serialized form\nItem 76: Write readObject methods defensively\nItem 77: For instance control, prefer enum types to readResolve\nItem 78: Consider serialization proxies instead of serialized instances\nAppendix: Items Corresponding to First Edition\nReferences\nIndex', '2696119', 'https://img3.doubanio.com/view/subject/m/public/s3259732.jpg', '0321356683', '9780321356680', '346', 'USD 54.99', '2008-05-28', 'Addison-Wesley', 'Java', 'Written for the working Java developer, Joshua Bloch\'s Effective Java Programming Language Guide provides a truly useful set of over 50 best practices and tips for writing better Java code. With plenty of advice from an indisputable expert in the field, this title is sure to be an indispensable resource for anyone who wants to get more out of their code.\nAs a veteran developer at Sun, the author shares his considerable insight into the design choices made over the years in Sun\'s own Java libraries (which the author acknowledges haven\'t always been perfect). Based on his experience working with Sun\'s best minds, the author provides a compilation of 57 tips for better Java code organized by category. Many of these ideas will let you write more robust classes that better cooperate with built-in Java APIs. Many of the tips make use of software patterns and demonstrate an up-to-the-minute sense of what works best in today\'s design. Each tip is clearly introduced and explained with code snippets used to demonstrate each programming principle.\nEarly sections on creating and destroying objects show you ways to make better use of resources, including how to avoid duplicate objects. Next comes an absolutely indispensable guide to implementing \"required\" methods for custom classes. This material will help you write new classes that cooperate with old ones (with advice on implementing essential requirements like the equals() and hashCode() methods).\nThe author has a lot to say about class design, whether using inheritance or composition. Tips on designing methods show you how to create understandable, maintainable, and robust classes that can be easily reused by others on your team. Sections on mapping C code (like structures, unions, and enumerated types) onto Java will help C programmers bring their existing skills to Sun\'s new language. Later sections delve into some general programming tips, like using exceptions effectively. The book closes with advice on using threads and synchronization techniques, plus some worthwhile advice on object serialization.\nWhatever your level of Java knowledge, this title can make you a more effective programmer. Wisely written, yet never pompous or doctrinaire, the author has succeeded in packaging some really valuable nuggets of advice into a concise and very accessible guidebook that arguably deserves a place on most any developer\'s bookshelf. --Richard Dragan\nTopics covered:\nBest practices and tips for Java\nCreating and destroying objects (static factory methods, singletons, avoiding duplicate objects and finalizers)\nRequired methods for custom classes (overriding equals(), hashCode(), toString(), clone(), and compareTo() properly)\nHints for class and interface design (minimizing class and member accessibility, immutability, composition versus inheritance, interfaces versus abstract classes, preventing subclassing, static versus nonstatic classes)\nC constructs in Java (structures, unions, enumerated types, and function pointers in Java)\nTips for designing methods (parameter validation, defensive copies, method signatures, method overloading, zero-length arrays, hints for Javadoc comments)\nGeneral programming advice (local variable scope, using Java API libraries, avoiding float and double for exact comparisons, when to avoid strings, string concatenation, interfaces and reflection, avoid native methods, optimizing hints, naming conventions)\nProgramming with exceptions (checked versus run-time exceptions, standard exceptions, documenting exceptions, failure-capture information, failure atomicity)\nThreading and multitasking (synchronization and scheduling hints, thread safety, avoiding thread groups)\nSerialization (when to implement Serializable, the readObject(), and readResolve() methods)', 'java;Java;programming;编程;计算机;Effective;软件开发;程序设计;', '[]', 'https://api.douban.com/v2/book/2696119');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/3178601/', 'Practical API Design', '[\"Jaroslav Tulach\"]', 'Hardcover', '', '3178601', 'https://img3.doubanio.com/view/subject/m/public/s4356554.jpg', '1430209739', '9781430209737', '416', 'USD 74.99', '2008-7-29', 'Apress', 'Confessions of a Java Framework Architect', '', 'API;软件设计;Programming;架构;设计;设计模式;软件开发;计算机;', '[]', 'https://api.douban.com/v2/book/3178601');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/3351237/', '数据结构与算法分析', '[\"韦斯 (Mark Allen Weiss)\"]', '平装', '译者序\n前言\n第1章 引论\n1.1 本书讨论的内容\n1.2 数学知识复习\n1.2.1 指数\n1.2.2 对数\n1.2.3 级数\n1.2.4 模运算\n1.2.5 证明的方法\n1.3 递归简论\n1.4 实现泛型特性构件pre-Java5\n1.4.1 使用Object表示泛型\n1.4.2 基本类型的包装\n1.4.3 使用接口类型表示泛型\n1.4.4 数组类型的兼容性\n1.5 利用Java5泛性实现泛型特性成分\n1.5.1 简单的泛型类和接口\n1.5.2 自动装箱/拆箱\n1.5.3 带有限制的通配符\n1.5.4 泛型static方法\n1.5.5 类型限界\n1.5.6 类型擦除\n1.5.7 对于泛型的限制\n1.6 函数对象\n小结\n练习\n参考文献\n第2章 算法分析\n2.1 数学基础\n2.2 模型\n2.3 要分析的问题\n2.4 运行时间计算\n2.4.1 一个简单的例子\n2.4.2 一般法则\n2.4.3 最大子序列和问题的求解\n2.4.4 运行时间中的对数\n2.4.5 检验你的分析\n2.4.6 分析结果的准确性\n小结\n练习\n参考文献\n第3章 表、栈和队列\n3.1 抽象数据类型\n3.2 表ADT\n3.2.1 表的简单数组实现\n3.2.2 简单链表\n3.3 Java Collections API中的表\n3.3.1 Collection接口\n3.3.2 Iterator接口\n3.3.3 List接口、ArrayList类和LinkedList类\n3.3.4 例：remove方法对LinkedList类的使用\n3.3.5 关于ListIterator接口\n3.4 ArrayList类的实现\n3.4.1 基本类\n3.4.2 迭代器、Java嵌套类和内部类\n3.5 Linked List类的实现\n3.6 栈ADT\n3.6.1 栈模型\n3.6.2 栈的实现\n3.6.3 应用\n3.7 队列ADT\n3.7.1 队列模型\n3.7.2 队列的数组实现\n3.7.3 队列的应用\n小结\n练习\n第4章 树\n4.1 预备知识\n4.1.1 树的实现\n4.1.2 树的遍历及应用\n4.2 二叉树\n4.2.1 实现\n4.2.2 例子：表达式树\n4.3 查找树ADT——二叉查找树\n4.3.1 contains方法\n4.3.2 findMin方法和findMax方法\n4.3.3 insert方法\n4.3.4 remove方法\n4.3.5 平均情况分析\n4.4 AVL树\n4.4.1 单旋转\n4.4.2 双旋转\n4.5 伸展树\n4.5.1 一个简单的想法（不能直接使用）\n4.5.2 展开\n4.6 树的遍历\n4.7 B树\n4.8 标准库中的集合与映射\n4.8.1 关于Set接口\n4.8.2 关于Map接口\n4.8.3 TreeSet类和TreeMap类的实现\n4.8.4 使用多个映射的例\n小结\n练习\n参考文献\n第5章 散列\n5.1 一般想法\n5.2 散列函数\n5.3 分离链接法\n5.4 不用链表的散列表\n5.4.1 线性探测法\n5.4.2 平方探测法\n5.4.3 双散列\n5.5 再散列\n5.6 标准库中的散列表\n5.7 可扩散列\n小结\n练习\n参考文献\n第6章 优先队列（堆）\n6.1 模型\n6.2 一些简单的实现\n6.3 二叉堆\n6.3.1 结构性质\n6.3.2 堆序性质\n6.3.3 基本的堆操作\n6.3.4 其他的堆操作\n6.4 优先队列的应用\n6.4.1 选择问题\n6.4.2 事件模拟\n6.5 d-堆\n6.6 左式堆\n6.6.1 左式堆性质\n6.6.2 左式堆操作\n6.7 斜堆\n6.8 二项队列\n6.8.1 二项队列结构\n6.8.2 二项队列操作\n6.8.3 二项队列的实现\n6.9 标准库中的优先队列\n小结\n练习\n参考文献\n第7章 排序\n7.1 预备知识\n7.2 插入排序\n7.2.1 算法\n7.2.2 插入排序的分析\n7.3 一些简单排序算法的下界\n7.4 希尔排序\n7.5 堆排序\n7.6 归并排序\n7.7 快速排序\n7.7.1 选取枢纽元\n7.7.2 分割策略\n7.7.3 小数组\n7.7.4 实际的快速排序例程\n7.7.5 快速排序的分析\n7.7.6 选择问题的线性期望时间算法\n7.8 排序算法的一般下界\n7.9 桶式排序\n7.10 外部排序\n7.10.1 为什么需要一些新的算法\n7.10.2 外部排序模型\n7.10.3 简单算法\n7.10.4 多路合并\n7.10.5 多相合并\n7.10.6 替换选择\n小结\n练习题\n参考文献\n第8章 不相交集类\n8.1 等价关系\n8.2 动态等价性问题\n8.3 基本数据结构\n8.4 灵巧求并算法\n8.5 路径压缩\n8.6 路径压缩和按秩求并的最坏情形\n8.7 一个应用\n小结\n练习题\n参考文献\n第9章 图论算法\n9.1 若干定义\n9.2 拓扑排序\n9.3 最短路径算法\n9.3.1 无权最短路径\n9.3.2 Dijkstra算法\n9.3.3 具有负边值的图\n9.3.4 无圈图\n9.3.5 所有点对最短路径\n9.3.6 最短路径的例子\n9.4 网络流问题\n9.5 最小生成树\n9.5.1 Prim算法\n9.5.2 Kruskal算法\n9.6 深度优先搜索的应用\n9.6.1 无向图\n9.6.2 双连通性\n9.6.3 欧拉回路\n9.6.4 有向图\n9.6.5 查找强分支\n9.7 NP完全性介绍\n9.7.1 难与易\n9.7.2 NP类\n9.7.3 NP完全问题\n小结\n练习\n参考文献\n第10章 算法设计技巧\n10.1 贪婪算法\n10.1.1 一个简单的调度问题\n10.1.2 哈夫曼编码\n10.1.3 近似装箱问题\n10.2 分治算法\n10.2.1 分治算法的运行时间\n10.2.2 最近点问题\n10.2.3 选择问题\n10.2.4 一些算术问题的理论改进\n10.3 动态规划\n10.3.1 用一个表代替递归\n10.3.2 矩阵乘法的顺序安排\n10.3.3 最优二叉查找树\n10.3.4 所有点对最短路径\n10.4 随机化算法\n10.4.1 随机数发生器\n10.4.2 跳跃表\n10.4.3 素性测试\n10.5 回溯算法\n10.5.1 收费公路重建问题\n10.5.2 博弈\n小结\n练习\n参考文献\n第11章 摊还分析\n11.1 一个无关的智力问题\n11.2 二项队列\n11.3 斜堆\n11.4 斐波那契堆\n11.4.1 切除左式堆中的节点\n11.4.2 二项队列的懒惰合并\n11.4.3 斐波那契堆操作\n11.4.4 时间界的证明\n11.5 伸展树\n小结\n练习\n参考文献\n第12章 高级数据结构及其实现\n12.1 自顶向下伸展树\n12.2 红黑树\n12.2.1 自底向上的插入\n12.2.2 自顶向下红黑树\n12.2.3 自顶向下的删除\n12.3 确定性跳跃表\n12.4 AA树\n12.5 treap树\n12.6 k-d树\n12.7 配对堆\n小结\n练习\n参考文献\n索引', '3351237', 'https://img3.doubanio.com/view/subject/m/public/s28318872.jpg', '711123183X', '9787111231837', '400', '55.00元', '2009-1-1', '机械工业出版社', 'Java语言描述', '本书是国外数据结构与算法分析方面的经典教材，使用卓越的Java编程语言作为实现工具讨论了数据结构（组织大量数据的方法）和算法分析（对算法运行时间的估计）。    随着计算机速度的不断增加和功能的日益强大，人们对有效编程和算法分析的要求也不断增长。本书把算法分析与最有效率的Java程序的开发有机地结合起来，深入分析每种算法，内容全面、缜密严格，并细致讲解精心构造程序的方法。', '数据结构;Java;算法;算法、数据结构;计算机;编程;java;程序设计;', '[]', 'https://api.douban.com/v2/book/3351237');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/3360807/', 'Effective java 中文版（第2版）', '[\"Joshua Bloch\"]', '平装', '译者序\n序\n前言\n致谢\n第1章 引言\n第2章 创建和销毁对象\n第1条：考虑用静态工厂方法代替构造器\n第2条：遇到多个构造器参数时要考虑用构建器\n第3条：用私有构造器或者枚举类型强化Singleton属性\n第4条：通过私有构造器强化不可实例化的能力\n第5条：避免创建不必要的对象\n第6条：消除过期的对象引用\n第7条：避免使用终结方法\n第3章 对于所有对象都通用的方法\n第8条：覆盖equals时请遵守通用约定\n第9条：覆盖equals时总要覆盖hashCode\n第10条：始终要覆盖toString\n第11条：谨慎地覆盖clone\n第12条：考虑实现Comparable接口\n第4章 类和接口\n第13条：使类和成员的可访问性最小化\n第14条：在公有类中使用访问方法而非公有域\n第15条：使可变性最小化\n第16条：复合优先于继承\n第17条：要么为继承而设计，并提供文档说明，要么就禁止继承\n第18条：接口优于抽象类\n第19条：接口只用于定义类型\n第20条：类层次优于标签类\n第21条：用函数对象表示策略\n第22条：优先考虑静态成员类\n第5章 泛型\n第23条：请不要在新代码中使用原生态类型\n第24条：消除非受检警告\n第25条：列表优先于数组\n第26条：优先考虑泛型\n第27条：优先考虑泛型方法\n第28条：利用有限制通配符来提升API的灵活性\n第29条：优先考虑类型安全的异构容器\n第6章 枚举和注解\n第30条：用enum代替int常量\n第31条：用实例域代替序数\n第32条：用EnumSet代替位域\n第33条：用EnumMap代替序数索引\n第34条：用接口模拟可伸缩的枚举\n第35条：注解优先于命名模式\n第36条：坚持使用Override注解\n第37条：用标记接口定义类型\n第7章 方法\n第38条：检查参数的有效性\n第39条：必要时进行保护性拷贝\n第40条：谨慎设计方法签名\n第41条：慎用重载\n第42条：慎用可变参数\n第43条：返回零长度的数组或者集合，而不是：null\n第44条：为所有导出的API元素编写文档注释\n第8章 通用程序设计\n第45条：将局部变量的作用域最小化\n第46条：for-each循环优先于传统的for循环\n第47条：了解和使用类库\n第48条：如果需要精确的答案，请避免使用float和double\n第49条：基本类型优先于装箱基本类型\n第50条：如果其他类型更适合，则尽量避免使用字符串\n第51条：当心字符串连接的性能\n第52条：通过接口引用对象\n第53条：接口优先于反射机制\n第54条：谨慎地使用本地方法\n第55条：谨慎地进行优化\n第56条：遵守普遍接受的命名惯例\n第9章 异常\n第57条：只针对异常的情况才使用异常\n第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常\n第59条：避免不必要地使用受检的异常\n第60条：优先使用标准的异常\n第61条：抛出与抽象相对应的异常\n第62条：每个方法抛出的异常都要有文档\n第63条：在细节消息中包含能捕获失败的信息\n第64条：努力使失败保持原子性\n第65条：不要忽略异常\n第10章 并发\n第66条：同步访问共享的可变数据\n第67条：避免过度同步\n第68条：executor和task优先干线程\n第69条：并发工具优先于wait和notify\n第70条：线程安全性的文档化\n第71条：慎用延迟初始化\n第72条：不要依赖于线程调度器\n第73条：避免使用线程组\n第11章 序列化\n第74条：谨慎地实现Serializable接口\n第75条：考虑使用自定义的序列化形式\n第76条：保护性地编写readObject方法\n第77条：对于实例控制，枚举类型优先于readResolve\n第78条：考虑用序列化代理代替序列化实例\n附录 第1版与第2版条目对照\n中英文术语对照\n参考文献', '3360807', 'https://img3.doubanio.com/view/subject/m/public/s3479802.jpg', '7111255836', '9787111255833', '287', '52.00元', '2009-1-1', '机械工业出版社', '', '本书介绍了在Java编程中78条极具实用价值的经验规则，这些经验规则涵盖了大多数开发人员每天所面临的问题的解决方案。通过对Java平台设计专家所使用的技术的全面描述，揭示了应该做什么，不应该做什么才能产生清晰、健壮和高效的代码。\n本书中的每条规则都以简短、独立的小文章形式出现，并通过例子代码加以进一步说明。本书内容全面，结构清晰，讲解详细。可作为技术人员的参考用书。', 'java;Java;编程;effective;计算机;程序设计;经典;软件开发;', '[\"俞黎敏\"]', 'https://api.douban.com/v2/book/3360807');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/4822875/', 'Java', '[\"Jim Waldo\"]', 'Paperback', '', '4822875', 'https://img1.doubanio.com/view/subject/m/public/s28362087.jpg', '0596803737', '9780596803735', '196', 'USD 29.99', '2010-5-9', 'O\'Reilly Media', 'The Good Parts', 'What if you could condense Java down to its very best features and build better applications with that simpler version? In this book, veteran Sun Labs engineer Jim Waldo reveals which parts of Java are most useful, and why those features make Java among the best programming languages available.    Every language eventually builds up crud, Java included. The core language has become increasingly large and complex, and the libraries associated with it have grown even more. Learn how to take advantage of Java\'s best features by working with an example application throughout the book. You may not like some of the features Jim Waldo considers good, but they\'ll actually help you write better code.    Learn how the type system and packages help you build large-scale software   Use exceptions to make code more reliable and easier to maintain   Manage memory automatically with garbage collection   Discover how the JVM provides portability, security, and nearly bug-free code   Use Javadoc to embed documentation within the code   Take advantage of reusable data structures in the collections library   Use Java RMI to move code and data in a distributed network   Learn how Java concurrency constructs let you exploit multicore processors', 'Java;编程语言;O\'Reilly;计算机;英文版;编程;程序设计;软件开发;', '[]', 'https://api.douban.com/v2/book/4822875');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/4909629/', 'Scala程序设计', '[\"[美]Venkat Subramaniam\"]', '', '第1章 简介	1\n1.1 为何选择Scala	1\n1.2 何为Scala	3\n1.3 函数式编程	7\n1.4 本书的内容	9\n1.5 本书面向的读者	11\n1.6 致谢	11\n第2章 起步	13\n2.1 下载Scala	13\n2.2 安装Scala	13\n2.2.1 在Windows上安装Scala	14\n2.2.2 在类UNIX系统上安装Scala	14\n2.3 让Scala跑起来	15\n2.4 命令行上的Scala	16\n2.5 把Scala代码当作脚本运行	17\n2.5.1 在类UNIX系统上作为脚本运行	17\n2.5.2 在Windows上作为脚本运行	18\n2.6 在IDE里面运行Scala	18\n2.7 编译Scala	19\n第3章 Scala步入正轨	20\n3.1 把Scala当作简洁的Java	20\n3.2 Java基本类型对应的Scala类	23\n3.3 元组与多重赋值	23\n3.4 字符串与多行原始字符串	25\n3.5 自适应的默认做法	26\n3.6 运算符重载	27\n3.7 Scala带给Java程序员的惊奇	29\n3.7.1 赋值的结果	29\n3.7.2 Scala的==	30\n3.7.3 分号是半可选的	31\n3.7.4 默认的访问修饰符	32\n3.7.5 默认的访问修饰符以及如何修改	32\n3.7.6 Scala的Protected	33\n3.7.7 细粒度访问控制	34\n3.7.8 避免显式return	35\n第4章 Scala的类	37\n4.1 创建类	37\n4.2 定义字段、方法和构造函数	38\n4.3 类继承	41\n4.4 单例对象	42\n4.5 独立对象和伴生对象	43\n4.6 Scala中的static	44\n第5章 自适应类型	46\n5.1 容器和类型推演	47\n5.2 Any类型	49\n5.3 关于Nothing的更多情况	50\n5.4 Option类型	50\n5.5 方法返回类型推演	51\n5.6 传递变参	52\n5.7 参数化类型的可变性	53\n第6章 函数值和闭包	57\n6.1 从普通函数迈向高阶函数	57\n6.2 函数值	58\n6.3 具有多参数的函数值	59\n6.4 Curry化	61\n6.5 重用函数值	62\n6.6 参数的位置记法	64\n6.7 Execute Around Method模式	65\n6.8 偏应用函数	67\n6.9 闭包	68\n第7章 Trait和类型转换	70\n7.1 Trait	70\n7.2 选择性混入	72\n7.3 以trait进行装饰	74\n7.4 Trait方法的延迟绑定	75\n7.5 隐式类型转换	77\n第8章 使用容器	81\n8.1 常见的Scala容器	81\n8.2 使用Set	82\n8.3 使用Map	83\n8.4 使用List	85\n8.5 for表达式	90\n第9章 模式匹配和正则表达式	93\n9.1 匹配字面量和常量	93\n9.2 匹配通配符	94\n9.3 匹配元组和列表	94\n9.4 类型和卫述句的匹配	96\n9.5 case表达式里的模式变量和常量	96\n9.6 对XML片段进行模式匹配	98\n9.7 使用case类进行模式匹配	98\n9.8 使用提取器进行匹配	100\n9.9 正则表达式	103\n9.10 把正则表达式当做提取器	104\n第10章 并发编程	106\n10.1 促进不变性	106\n10.2 使用Actor的并发	107\n10.3 消息传递	110\n10.4 Actor类	113\n10.5 actor方法	115\n10.6 receive和receiveWithin方法	117\n10.7 react和reactWithin方法	120\n10.8 loop和loopWhile	124\n10.9 控制线程执行	125\n10.10 在各种接收方法中选择	127\n第11章 与Java互操作	128\n11.1 在Scala里使用Scala类	128\n11.2 在Scala里使用Java类	130\n11.3 在Java里使用Scala类	132\n11.3.1 有普通函数和高阶函数的Scala类	132\n11.3.2 同trait一起工作	134\n11.3.3 单例对象和伴生对象	134\n11.4 继承类	136\n第12章 用Scala做单元测试	138\n12.1 使用JUnit	138\n12.2 使用ScalaTest	139\n12.3 以Canary测试开始	140\n12.4 使用Runner	140\n12.5 Asserts	142\n12.6 异常测试	144\n12.7 在测试间共享代码	146\n12.7.1 用BeforeAndAfter共享代码	146\n12.7.2 用闭包共享代码	147\n12.8 FunSuite的函数式风格	148\n12.9 用JUnit运行ScalaTest	149\n第13章 异常处理	152\n13.1 异常处理	152\n13.2 注意catch顺序	154\n第14章 使用Scala	156\n14.1 净资产应用实例	156\n14.2 获取用户输入	156\n14.3 读写文件	157\n14.4 XML，作为一等公民	159\n14.5 读写XML	161\n14.6 从Web获取股票价格	164\n14.7 让净资产应用并发	167\n14.8 为净资产应用增加GUI	168\n附录A Web资源	178', '4909629', 'https://img3.doubanio.com/view/subject/m/public/s4911906.jpg', '7115232954', '9787115232953', '180', '39.00', '2010-8', '人民邮电出版社', 'Java虚拟机多核编程实战', 'Scala是一种针对 JVM 的通用的编程语言，用来以简明、优雅、类型安全的方式表示常见的编程模式。它无缝集成了面向对象语言和函数式语言的特性，可以大大提高JAVA程序员的编程效率。Twitter、SAP等知名企业已经开始在一些应用里使用Scala，很多新的程序员也开始学习它。\n本书循序渐进地介绍了Scala的函数式编程基础，虽然篇幅短小，却切中要害。读者可以学会使用Scala静态语言的强大功能创建简洁、可扩展、高度可并行的代码。对于多核时代JVM上的并发编程，Scala是绝好的工具，而本书是你必不可少的向导。', 'scala;Java;函数式编程;多核编程;编程;计算机;编程语言;程序设计;', '[\"郑晔\",\"李剑\"]', 'https://api.douban.com/v2/book/4909629');
INSERT INTO `sunshine_book` VALUES ('https://book.douban.com/subject/7059903/', '编写高质量代码', '[\"秦小波\"]', '', '前言\n第1章　Java开发中通用的方法和准则/1\n建议1： 不要在常量和变量中出现易混淆的字母/2\n建议2： 莫让常量蜕变成变量/2\n建议3： 三元操作符的类型务必一致/3\n建议4： 避免带有变长参数的方法重载/4\n建议5： 别让null值和空值威胁到变长方法/6\n建议6： 覆写变长方法也循规蹈矩/7\n建议7： 警惕自增的陷阱/8\n建议8： 不要让旧语法困扰你/10\n建议9： 少用静态导入/11\n建议10： 不要在本类中覆盖静态导入的变量和方法/13\n建议11： 养成良好习惯，显式声明UID/14\n建议12： 避免用序列化类在构造函数中为不变量赋值/17\n建议13： 避免为final变量复杂赋值/19\n建议14： 使用序列化类的私有方法巧妙解决部分属性持久化问题/20\n建议15： break万万不可忘/23\n建议16： 易变业务使用脚本语言编写/25\n建议17： 慎用动态编译/27\n建议18： 避免instanceof非预期结果/29\n建议19： 断言绝对不是鸡肋/31\n建议20： 不要只替换一个类/33\n第2章　基本类型/35\n建议21： 用偶判断，不用奇判断/36\n建议22： 用整数类型处理货币/37\n建议23： 不要让类型默默转换/38\n建议24： 边界，边界，还是边界/39\n建议25： 不要让四舍五入亏了一方/41\n建议26： 提防包装类型的null值/43\n建议27： 谨慎包装类型的大小比较/45\n建议28： 优先使用整型池/46\n建议29： 优先选择基本类型/48\n建议30： 不要随便设置随机种子/49\n第3章　类、对象及方法/52\n建议31： 在接口中不要存在实现代码/53\n建议32： 静态变量一定要先声明后赋值/54\n建议33： 不要覆写静态方法/55\n建议34： 构造函数尽量简化/57\n建议35： 避免在构造函数中初始化其他类/58\n建议36： 使用构造代码块精炼程序/60\n建议37： 构造代码块会想你所想/61\n建议38： 使用静态内部类提高封装性/63\n建议39： 使用匿名类的构造函数/65\n建议40： 匿名类的构造函数很特殊/66\n建议41： 让多重继承成为现实/68\n建议42： 让工具类不可实例化/70\n建议43： 避免对象的浅拷贝/71\n建议44： 推荐使用序列化实现对象的拷贝/73\n建议45： 覆写equals方法时不要识别不出自己/74\n建议46： equals应该考虑null值情景/76\n建议47： 在equals中使用getClass进行类型判断/77\n建议48： 覆写equals方法必须覆写hashCode方法/78\n建议49： 推荐覆写toString方法/80\n建议50： 使用package-info类为包服务/81\n建议51： 不要主动进行垃圾回收/82\n第4章　字符串/83\n建议52： 推荐使用String直接量赋值/84\n建议53： 注意方法中传递的参数要求/85\n建议54： 正确使用String、StringBuffer、StringBuilder/86\n建议55： 注意字符串的位置/87\n建议56： 自由选择字符串拼接方法/88\n建议57： 推荐在复杂字符串操作中使用正则表达式/90\n建议58： 强烈建议使用UTF编码/92\n建议59： 对字符串排序持一种宽容的心态/94\n第5章　数组和集合/97\n建议60： 性能考虑，数组是首选/98\n建议61： 若有必要，使用变长数组/99\n建议62： 警惕数组的浅拷贝/100\n建议63： 在明确的场景下，为集合指定初始容量/101\n建议64： 多种最值算法，适时选择/104\n建议65： 避开基本类型数组转换列表陷阱/105\n建议66： asList方法产生的List对象不可更改/107\n建议67： 不同的列表选择不同的遍历方法/108\n建议68： 频繁插入和删除时使用LinkedList/112\n建议69： 列表相等只需关心元素数据/115\n建议70：子列表只是原列表的一个视图/117\n建议71： 推荐使用subList处理局部列表/119\n建议72： 生成子列表后不要再操作原列表/120\n建议73： 使用Comparator进行排序/122\n建议74： 不推荐使用binarySearch对列表进行检索/125\n建议75： 集合中的元素必须做到compareTo和equals同步/127\n建议76： 集合运算时使用更优雅的方式/129\n建议77： 使用shuffle打乱列表/131\n建议78： 减少HashMap中元素的数量/132\n建议79： 集合中的哈希码不要重复/135\n建议80： 多线程使用Vector或HashTable/139\n建议81： 非稳定排序推荐使用List/141\n建议82： 由点及面，一叶知秋—集合大家族/143\n第6章　枚举和注解/145\n建议83： 推荐使用枚举定义常量/146\n建议84： 使用构造函数协助描述枚举项/149\n建议85： 小心switch带来的空值异常/150\n建议86： 在switch的default代码块中增加AssertionError错误/152\n建议87： 使用valueOf前必须进行校验/152\n建议88： 用枚举实现工厂方法模式更简洁/155\n建议89： 枚举项的数量限制在64个以内/157\n建议90： 小心注解继承/160\n建议91： 枚举和注解结合使用威力更大/162\n建议92： 注意@Override不同版本的区别/164\n第7章　泛型和反射/166\n建议93： Java的泛型是类型擦除的/167\n建议94： 不能初始化泛型参数和数组/169\n建议95： 强制声明泛型的实际类型/170\n建议96： 不同的场景使用不同的泛型通配符/172\n建议97： 警惕泛型是不能协变和逆变的/174\n建议98： 建议采用的顺序是List<T>、List<?>、List<Object>/176\n建议99： 严格限定泛型类型采用多重界限/177\n建议100： 数组的真实类型必须是泛型类型的子类型/179\n建议101： 注意Class类的特殊性/181\n建议102： 适时选择getDeclared×××和get×××/181\n建议103： 反射访问属性或方法时将Accessible设置为true /182\n建议104： 使用forName动态加载类文件/184\n建议105： 动态加载不适合数组/186\n建议106： 动态代理可以使代理模式更加灵活/188\n建议107： 使用反射增加装饰模式的普适性/190\n建议108： 反射让模板方法模式更强大/192\n建议109： 不需要太多关注反射效率/194\n第8章　异常/197\n建议110： 提倡异常封装/198\n建议111： 采用异常链传递异常/200\n建议112： 受检异常尽可能转化为非受检异常/202\n建议113： 不要在finally块中处理返回值/204\n建议114： 不要在构造函数中抛出异常/207\n建议115： 使用Throwable获得栈信息/210\n建议116： 异常只为异常服务/212\n建议117： 多使用异常，把性能问题放一边/213\n第9章　多线程和并发/215\n建议118： 不推荐覆写start方法/216\n建议119： 启动线程前stop方法是不可靠的/218\n建议120： 不使用stop方法停止线程/220\n建议121： 线程优先级只使用三个等级/224\n建议122： 使用线程异常处理器提升系统可靠性/226\n建议123： volatile不能保证数据同步/228\n建议124： 异步运算考虑使用Callable接口/232\n建议125： 优先选择线程池/233\n建议126： 适时选择不同的线程池来实现/237\n建议127： Lock与synchronized是不一样的/240\n建议128： 预防线程死锁/245\n建议129： 适当设置阻塞队列长度/250\n建议130： 使用CountDownLatch协调子线程/252\n建议131： CyclicBarrier让多线程齐步走/254\n第10章　性能和效率/256\n建议132： 提升Java性能的基本方法/257\n建议133： 若非必要，不要克隆对象/259\n建议134： 推荐使用“望闻问切”的方式诊断性能/261\n建议135： 必须定义性能衡量标准/263\n建议136： 枪打出头鸟—解决首要系统性能问题/264\n建议137： 调整JVM参数以提升性能/266\n建议138： 性能是个大“咕咚”/268\n第11章　开源世界/271\n建议139： 大胆采用开源工具/272\n建议140： 推荐使用Guava扩展工具包/273\n建议141： Apache扩展包/276\n建议142： 推荐使用Joda日期时间扩展包/280\n建议143： 可以选择多种Collections扩展/282\n第12章　思想为源/285\n建议144： 提倡良好的代码风格/286\n建议145： 不要完全依靠单元测试来发现问题/287\n建议146： 让注释正确、清晰、简洁/290\n建议147： 让接口的职责保持单一/294\n建议148： 增强类的可替换性/295\n建议149： 依赖抽象而不是实现/298\n建议150： 抛弃7条不良的编码习惯/299\n建议151： 以技术员自律而不是工人/301', '7059903', 'https://img3.doubanio.com/view/subject/m/public/s7015915.jpg', '7111362594', '9787111362593', '303', '59.00元', '2011-12-28', '机械工业出版社华章公司', '改善Java程序的151个建议', '在通往“Java技术殿堂”的路上，本书将为你指点迷津！内容全部由Java编码的最佳实践组成，从语法、程序设计和架构、工具和框架、编码风格和编程思想等五大方面对Java程序员遇到的各种棘手的疑难问题给出了经验性的解决方案，为Java程序员如何编写高质量的Java代码提出了151条极为宝贵的建议。对于每一个问题，不仅以建议的方式从正反两面给出了被实践证明为十分优秀的解决方案和非常糟糕的解决方案，而且还分析了问题产生的根源，犹如醍醐灌顶，让人豁然开朗。\n全书一共12章，1~3章针对Java语法本身提出了51条建议，例如覆写变长方法时应该注意哪些事项、final修饰的常量不要在运行期修改、匿名类的构造函数特殊在什么地方等；4~9章重点针对JDK API的使用提出了80条建议，例如字符串的拼接方法该如何选择、枚举使用时有哪些注意事项、出现NullPointerException该如何处理、泛型的多重界限该如何使用、多线程编程如何预防死锁，等等；10~12章针对程序性能、开源的工具和框架、编码风格和编程思想等方面提出了20条建议。\n本书针对每个问题所设计应用场景都非常典型，给出的建议也都与实践紧密结合。书中的每一条建议都可能在你的下一行代码、下一个应用或下一个项目中崭露头角，建议你将此书搁置在手边，随时查阅，一定能使你的学习和开发工作事半功倍。', 'Java;编程;编写高质量代码;java;Programming;程序设计;技术;程序开发;', '[]', 'https://api.douban.com/v2/book/7059903');

-- ----------------------------
-- Table structure for sunshine_channel
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_channel`;
CREATE TABLE `sunshine_channel` (
  `channel_id` int(10) NOT NULL AUTO_INCREMENT,
  `channel_uri` varchar(255) NOT NULL,
  `channel_name_cn` varchar(255) NOT NULL,
  `channel_name_en` varchar(255) NOT NULL,
  `has_column` bit(1) NOT NULL DEFAULT b'1',
  `deleted` bit(1) NOT NULL DEFAULT b'0',
  PRIMARY KEY (`channel_id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_channel
-- ----------------------------
INSERT INTO `sunshine_channel` VALUES ('1', 'home', '首页', 'HOME', '', '\0');
INSERT INTO `sunshine_channel` VALUES ('2', 'tas', '师生风采', 'TEACHER AND STUDENT', '', '\0');
INSERT INTO `sunshine_channel` VALUES ('3', 'blog', '精彩博客', 'BLOG', '', '\0');
INSERT INTO `sunshine_channel` VALUES ('4', 'testtest', '测试用的', 'TEST', '', '\0');
INSERT INTO `sunshine_channel` VALUES ('5', 'paper', '论文', 'paper', '', '\0');

-- ----------------------------
-- Table structure for sunshine_column
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_column`;
CREATE TABLE `sunshine_column` (
  `column_id` int(10) NOT NULL AUTO_INCREMENT,
  `channel_id` int(10) NOT NULL,
  `column_uri` varchar(255) NOT NULL,
  `column_name_cn` varchar(255) NOT NULL,
  `column_name_en` varchar(255) NOT NULL,
  `deleted` bit(1) NOT NULL DEFAULT b'0',
  PRIMARY KEY (`column_id`)
) ENGINE=InnoDB AUTO_INCREMENT=6 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_column
-- ----------------------------
INSERT INTO `sunshine_column` VALUES ('1', '2', 'prof', '教授', 'PROF', '\0');
INSERT INTO `sunshine_column` VALUES ('2', '2', 'doctor', '博士', 'DOCTOR', '\0');
INSERT INTO `sunshine_column` VALUES ('3', '3', 'post', '硕士博客', 'STEPHEN', '\0');
INSERT INTO `sunshine_column` VALUES ('4', '3', 'test2', '测试2', 'test2', '\0');
INSERT INTO `sunshine_column` VALUES ('5', '4', '/test4', '测试栏目4', 'column of channel4', '');

-- ----------------------------
-- Table structure for sunshine_comment
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_comment`;
CREATE TABLE `sunshine_comment` (
  `comment_id` bigint(30) NOT NULL AUTO_INCREMENT,
  `comment_user_id` int(30) NOT NULL,
  `comment_on_bin_id` int(30) NOT NULL,
  `comment_on_bin_type` int(4) NOT NULL,
  `comment_content` longtext NOT NULL,
  `comment_date` timestamp NOT NULL DEFAULT '0000-00-00 00:00:00' ON UPDATE CURRENT_TIMESTAMP,
  `deleted` bit(1) NOT NULL DEFAULT b'0',
  PRIMARY KEY (`comment_id`),
  KEY `index_comment_bin` (`comment_on_bin_id`,`comment_on_bin_type`) USING BTREE
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sunshine_comment
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_degree
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_degree`;
CREATE TABLE `sunshine_degree` (
  `degree_id` int(10) NOT NULL,
  `degree_name_cn` varchar(255) DEFAULT NULL,
  `degree_name_en` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`degree_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_degree
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_history_log
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_history_log`;
CREATE TABLE `sunshine_history_log` (
  `log_id` bigint(32) NOT NULL AUTO_INCREMENT,
  `log_type` int(10) NOT NULL,
  `oper_user_id` int(30) NOT NULL,
  `oper_bin_id` int(30) NOT NULL,
  `ext` longtext,
  `create_date` datetime NOT NULL,
  PRIMARY KEY (`log_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sunshine_history_log
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_option
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_option`;
CREATE TABLE `sunshine_option` (
  `option_key` varchar(255) NOT NULL,
  `option_value` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`option_key`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_option
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_role_permission_relation
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_role_permission_relation`;
CREATE TABLE `sunshine_role_permission_relation` (
  `user_role` varchar(255) NOT NULL,
  `permission` varchar(255) NOT NULL,
  PRIMARY KEY (`user_role`,`permission`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_role_permission_relation
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_user
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_user`;
CREATE TABLE `sunshine_user` (
  `user_id` int(30) NOT NULL AUTO_INCREMENT,
  `user_no` varchar(10) NOT NULL,
  `user_name` varchar(255) DEFAULT NULL,
  `email` varchar(255) DEFAULT NULL,
  `user_role` int(10) DEFAULT NULL,
  `password` varchar(64) DEFAULT NULL,
  `title` varchar(255) DEFAULT NULL,
  `position` varchar(255) DEFAULT NULL,
  `department` varchar(255) DEFAULT NULL,
  `office` varchar(255) DEFAULT NULL,
  `mobile_phone` varchar(12) DEFAULT NULL,
  `office_phone` varchar(20) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB AUTO_INCREMENT=3 DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sunshine_user
-- ----------------------------
INSERT INTO `sunshine_user` VALUES ('1', 'MG1514018', 'stephen meng', 'mengfansai147@163.com', '0', 'f73263a1f09abb73b5a03cfb8cf6ede6', null, null, null, null, null, null);
INSERT INTO `sunshine_user` VALUES ('2', 'MG1514019', '戚尔鹏', '1581284397@qq.com', null, 'f390b0c57c44b9ed73af0314abfa89af', null, null, null, null, '15195980433', null);

-- ----------------------------
-- Table structure for sunshine_user_bin_behavior
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_user_bin_behavior`;
CREATE TABLE `sunshine_user_bin_behavior` (
  `user|_id` int(20) NOT NULL,
  `bin_id` int(30) NOT NULL,
  `type` int(4) NOT NULL,
  `create_date` datetime NOT NULL,
  `ext` varchar(255) DEFAULT NULL,
  PRIMARY KEY (`user|_id`,`bin_id`,`type`),
  CONSTRAINT `fk_user_id` FOREIGN KEY (`user|_id`) REFERENCES `sunshine_user` (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb4;

-- ----------------------------
-- Records of sunshine_user_bin_behavior
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_user_education_background
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_user_education_background`;
CREATE TABLE `sunshine_user_education_background` (
  `user_id` int(30) NOT NULL,
  `degree` int(10) DEFAULT NULL,
  `school` varchar(255) DEFAULT NULL,
  `start_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `end_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `note` longtext
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_user_education_background
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_user_paper
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_user_paper`;
CREATE TABLE `sunshine_user_paper` (
  `user_id` int(30) NOT NULL,
  `paper_name` varchar(1024) DEFAULT NULL,
  `paper_link` varchar(1024) DEFAULT NULL,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_user_paper
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_user_project
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_user_project`;
CREATE TABLE `sunshine_user_project` (
  `user_id` int(30) NOT NULL,
  `project_name` varchar(1024) DEFAULT NULL,
  `project_type` varchar(255) DEFAULT NULL,
  `start_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  `end_date` datetime DEFAULT NULL ON UPDATE CURRENT_TIMESTAMP,
  PRIMARY KEY (`user_id`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_user_project
-- ----------------------------

-- ----------------------------
-- Table structure for sunshine_user_role_relation
-- ----------------------------
DROP TABLE IF EXISTS `sunshine_user_role_relation`;
CREATE TABLE `sunshine_user_role_relation` (
  `user_id` int(30) NOT NULL,
  `user_role` varchar(255) NOT NULL,
  PRIMARY KEY (`user_id`,`user_role`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of sunshine_user_role_relation
-- ----------------------------
INSERT INTO `sunshine_user_role_relation` VALUES ('1', 'admin');
INSERT INTO `sunshine_user_role_relation` VALUES ('1', 'normal');
